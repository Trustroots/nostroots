                                                                        <!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostroots Web</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    
    <!-- MapLibre GL CSS -->
    <link href="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.css" rel="stylesheet" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --background: hsl(0, 0%, 100%);
            --foreground: hsl(0, 0%, 3.9%);
            --card: hsl(0, 0%, 100%);
            --card-foreground: hsl(0, 0%, 3.9%);
            --primary: hsl(167, 81.9%, 39%);
            --primary-foreground: hsl(0, 0%, 98%);
            --secondary: hsl(0, 0%, 96.1%);
            --secondary-foreground: hsl(0, 0%, 9%);
            --muted: hsl(0, 0%, 96.1%);
            --muted-foreground: hsl(0, 0%, 45.1%);
            --accent: hsl(0, 0%, 96.1%);
            --accent-foreground: hsl(0, 0%, 9%);
            --destructive: hsl(0, 100%, 50%);
            --border: hsl(0, 0%, 89.8%);
            --input: hsl(0, 0%, 89.8%);
            --ring: hsl(0, 0%, 63%);
            --radius: 0.625rem;
        }
        
        /* Dark mode theme - default */
        [data-theme="dark"],
        :root:not([data-theme="light"]) {
            --background: hsl(0, 0%, 3.9%);
            --foreground: hsl(0, 0%, 98%);
            --card: hsl(0, 0%, 7%);
            --card-foreground: hsl(0, 0%, 98%);
            --primary: hsl(167, 81.9%, 39%);
            --primary-foreground: hsl(0, 0%, 98%);
            --secondary: hsl(0, 0%, 14.9%);
            --secondary-foreground: hsl(0, 0%, 98%);
            --muted: hsl(0, 0%, 14.9%);
            --muted-foreground: hsl(0, 0%, 63.9%);
            --accent: hsl(0, 0%, 14.9%);
            --accent-foreground: hsl(0, 0%, 98%);
            --destructive: hsl(0, 100%, 50%);
            --border: hsl(0, 0%, 14.9%);
            --input: hsl(0, 0%, 14.9%);
            --ring: hsl(0, 0%, 83.1%);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: var(--background);
            color: var(--foreground);
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        .view {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            height: 100%;
        }
        
        /* Mobile-first responsive adjustments */
        @media (max-width: 768px) {
            .layer-controls {
                max-width: calc(100vw - 20px);
            }
            
            .modal-content {
                width: 95%;
                padding: 1.5rem;
            }
            
            /* Notes modal: full width, bottom 60% on mobile */
            #pluscode-notes-modal {
                align-items: flex-end;
                justify-content: center;
            }
            
            #pluscode-notes-modal .notes-modal-content {
                width: 100%;
                max-width: 100%;
                height: 60vh;
                max-height: 60vh;
                border-radius: var(--radius) var(--radius) 0 0;
                margin: 0;
            }
            
        }
        
        #map {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }
        
        /* Improve map panning performance and smoothness */
        .maplibregl-canvas {
            will-change: transform;
        }
        
        .map-container {
            position: relative;
            flex: 1;
            min-height: 400px;
            overflow: hidden;
        }
        
        /* Improve map controls styling */
        .maplibregl-ctrl-group {
            background: var(--card) !important;
            border-radius: var(--radius) !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05) !important;
            border: 1px solid var(--border) !important;
            backdrop-filter: blur(10px);
        }
        
        .maplibregl-ctrl button {
            background: transparent !important;
            border: none !important;
            color: var(--foreground) !important;
        }
        
        .maplibregl-ctrl button:hover {
            background: var(--accent) !important;
        }
        
        .maplibregl-ctrl-attrib {
            background: var(--card) !important;
            color: var(--foreground) !important;
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: calc(var(--radius) - 2px);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
        }
        
        .maplibregl-ctrl-attrib a {
            color: var(--primary);
        }
        
        /* Dark overlay layer controls - matching mobile app */
        .layer-controls {
            position: absolute;
            top: 40px;
            left: 10px;
            background: var(--card);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: var(--radius);
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
            min-width: 180px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .layer-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0;
            padding: 8px 4px;
        }
        
        .layer-control label:not(.toggle-switch) {
            cursor: pointer;
            user-select: none;
            font-size: 0.875rem;
            color: var(--foreground);
            flex: 1;
        }
        
        /* iOS-style toggle switch */
        .toggle-switch {
            position: relative;
            width: 51px;
            height: 31px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .toggle-switch input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--muted);
            border-radius: 31px;
            transition: background-color 0.3s ease;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: var(--card);
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .toggle-switch input:checked + .toggle-slider {
            background-color: #34c759; /* iOS green */
        }
        
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .toggle-switch input:focus + .toggle-slider {
            box-shadow: 0 0 1px rgba(0, 0, 0, 0.2);
        }
        
        /* Floating Settings Button */
        .settings-icon {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--primary);
            color: var(--primary-foreground);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .settings-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }
        
        .settings-icon:active {
            transform: scale(0.95);
        }
        
        .settings-section {
            background: var(--card);
            padding: 1.25rem;
            margin-bottom: 1rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .settings-section h2 {
            margin-bottom: 1rem;
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--foreground);
        }
        
        .form-group {
            margin-bottom: 1rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--foreground);
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--input);
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.875rem;
            background: var(--background);
            color: var(--foreground);
            transition: border-color 0.2s ease;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px hsla(var(--primary), 0.1);
        }
        
        .form-group input[readonly] {
            background: var(--muted);
            cursor: not-allowed;
        }
        
        /* Improved Keys Section Styles */
        .key-input-wrapper {
            position: relative;
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }
        
        .key-input-wrapper input {
            flex: 1;
            padding-right: 3rem;
        }
        
        .copy-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--muted-foreground);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.75rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .copy-btn:hover {
            background: var(--secondary);
            color: var(--foreground);
        }
        
        .copy-btn:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .copy-btn.copied {
            color: var(--primary);
        }
        
        .nip07-card {
            background: var(--muted);
            border: 1px solid var(--border);
            border-radius: calc(var(--radius) - 2px);
            padding: 1rem;
            margin-top: 0.5rem;
        }
        
        .nip07-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        
        .nip07-header label {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--foreground);
        }
        
        .nip07-header input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
        }
        
        .nip07-description {
            font-size: 0.8125rem;
            color: var(--muted-foreground);
            line-height: 1.5;
            margin-bottom: 0.75rem;
        }
        
        .nip07-description strong {
            color: var(--foreground);
            font-weight: 600;
        }
        
        .nip07-status {
            font-size: 0.8125rem;
            padding: 0.5rem 0.75rem;
            border-radius: calc(var(--radius) - 2px);
            margin-top: 0.75rem;
            display: none;
            background: hsla(167, 81.9%, 39%, 0.1);
            color: var(--primary);
            border: 1px solid hsla(167, 81.9%, 39%, 0.2);
        }
        
        .nip07-status.show {
            display: block;
        }
        
        .username-nostr-indicator {
            font-size: 0.8125rem;
            color: var(--muted-foreground);
            margin-top: 0.5rem;
            font-style: italic;
        }
        
        .action-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        
        .action-buttons .btn {
            flex: 1;
            min-width: 120px;
        }
        
        .key-section-divider {
            height: 1px;
            background: var(--border);
            margin: 1.25rem 0;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: calc(var(--radius) - 2px);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            background: var(--primary);
            color: var(--primary-foreground);
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .btn:hover {
            background: hsl(167, 81.9%, 35%);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }
        
        .btn:active {
            background: hsl(167, 81.9%, 32%);
        }
        
        .btn-secondary {
            background: var(--secondary);
            color: var(--secondary-foreground);
        }
        
        .btn-secondary:hover {
            background: var(--muted);
        }
        
        [data-theme="dark"] .btn-secondary:hover,
        :root:not([data-theme="light"]) .btn-secondary:hover {
            background: hsl(0, 0%, 20%);
        }
        
        .btn.btn-danger {
            background: #ef4444 !important;
            color: white !important;
        }
        
        .btn.btn-danger:hover {
            background: #dc2626 !important;
        }
        
        .btn.btn-danger:active {
            background: #b91c1c !important;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .btn:disabled:hover {
            background: var(--primary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        /* Circles Button */
        .circles-button {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--primary);
            border-radius: calc(var(--radius) - 2px);
            background: var(--primary);
            color: var(--primary-foreground);
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 500;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .circles-button:hover {
            background: hsl(167, 81.9%, 35%);
            border-color: hsl(167, 81.9%, 35%);
        }
        
        .circles-button:active {
            transform: scale(0.95);
        }
        
        /* Circles List */
        .circles-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.5rem;
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: calc(var(--radius) - 2px);
            background: var(--muted);
        }
        
        /* Relays List */
        .relays-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .relay-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.875rem 1rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: calc(var(--radius) - 2px);
            transition: all 0.2s ease;
        }
        
        .relay-item:hover {
            border-color: var(--primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .relay-status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: all 0.3s ease;
            background: #6b7280; /* Default grey for disconnected */
        }
        
        .relay-status-indicator.connected {
            background: #10b981 !important;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
        
        .relay-status-indicator.connecting {
            background: #f59e0b !important;
            animation: pulse 2s infinite;
        }
        
        .relay-status-indicator.disconnected {
            background: #6b7280 !important;
        }
        
        .relay-status-indicator.error {
            background: #ef4444 !important;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        .relay-url {
            flex: 1;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 0.75rem;
            color: var(--foreground);
            word-break: break-all;
        }
        
        .relay-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .relay-delete-btn {
            padding: 0.375rem 0.75rem;
            background: transparent;
            border: 1px solid #ef4444;
            border-radius: calc(var(--radius) - 2px);
            color: #ef4444;
            font-size: 0.8125rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .relay-delete-btn:hover {
            background: #ef4444;
            color: white;
        }
        
        .circle-item {
            padding: 0.5rem 0.75rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: calc(var(--radius) - 2px);
            cursor: pointer;
            text-align: center;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .circle-item:hover {
            background: var(--accent);
            border-color: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .circle-item:active {
            transform: translateY(0);
        }
        
        .notes-add-form-row {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--card);
            padding: 2rem;
            border-radius: var(--radius);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            position: relative;
        }
        
        #settings-modal .github-icon-link {
            display: block;
            text-align: right;
            margin-top: 1rem;
            color: var(--foreground);
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        
        #settings-modal .github-icon-link svg {
            vertical-align: middle;
        }
        
        #settings-modal .github-icon-link:hover {
            opacity: 1;
        }
        
        .notes-modal-content {
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            margin: 0;
        }
        
        .notes-modal-content .modal-header {
            flex-shrink: 0;
        }
        
        .notes-modal-content .notes-list {
            flex: 1;
            min-height: 0;
        }
        
        .notes-modal-content .notes-actions {
            flex-shrink: 0;
        }
        
        .notes-list {
            margin: 0.15rem 0;
            max-height: calc(80vh - 200px);
            overflow-y: auto;
            padding-right: 0.4rem;
        }
        
        .notes-section {
            margin-bottom: 0.5rem;
        }
        
        .notes-section-header {
            padding: 0.25rem 0.5rem;
            border-radius: calc(var(--radius) - 2px);
            margin-bottom: 0.3rem;
            font-weight: 500;
            font-size: 0.75rem;
        }
        
        .notes-section-header.exact {
            background: rgba(59, 130, 246, 0.15);
            color: hsl(217, 91%, 60%);
            border-left: 4px solid rgb(59, 130, 246);
        }
        
        [data-theme="dark"] .notes-section-header.exact,
        :root:not([data-theme="light"]) .notes-section-header.exact {
            background: rgba(59, 130, 246, 0.2);
            color: hsl(217, 91%, 70%);
        }
        
        .notes-section-header.within {
            background: rgba(34, 197, 94, 0.15);
            color: hsl(142, 71%, 45%);
            border-left: 4px solid rgb(34, 197, 94);
        }
        
        [data-theme="dark"] .notes-section-header.within,
        :root:not([data-theme="light"]) .notes-section-header.within {
            background: rgba(34, 197, 94, 0.2);
            color: hsl(142, 71%, 55%);
        }
        
        .notes-section-header code {
            font-family: monospace;
            font-weight: 700;
            font-size: 0.9em;
        }
        
        .note-item {
            background: var(--muted);
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.15rem;
            border-radius: 8px;
            border: none;
            transition: background 0.15s ease;
            position: relative;
        }
        
        .note-item:hover {
            background: var(--accent);
        }
        
        .note-item.selected {
            background: var(--accent);
        }
        
        .note-content {
            color: var(--foreground);
            line-height: 1.3;
            font-size: 0.9rem;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        
        .event-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .note-meta-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.15rem;
        }
        
        .note-meta {
            font-size: 0.7rem;
            color: var(--muted-foreground);
            display: inline-block;
        }
        
        .note-author {
            color: var(--muted-foreground);
            font-size: 0.7rem;
            display: inline-block;
            font-family: inherit;
            opacity: 0.8;
        }
        
        .note-expiry {
            font-size: 0.65rem;
            display: inline-block;
            font-family: inherit;
            opacity: 0.9;
            white-space: nowrap;
        }
        
        /* Delete button styles - subtle icon only */
        .note-delete-btn {
            padding: 0;
            font-size: 0.85rem;
            background: transparent;
            color: var(--muted-foreground);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.5;
            line-height: 1;
            margin-left: 0.5rem;
        }
        
        .note-delete-btn:hover {
            opacity: 1;
            color: var(--destructive);
            transform: scale(1.1);
        }
        
        .note-delete-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }
        
        .note-delete-btn.deleting {
            opacity: 1;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .note-delete-btn.deleted {
            color: #10b981;
            opacity: 1;
            cursor: default;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        .notes-actions {
            margin-top: 0.2rem;
            padding-top: 0.2rem;
        }
        
        .notes-add-form {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }
        
        .notes-add-form textarea {
            min-height: 40px;
            max-height: 120px;
            resize: vertical;
            padding: 0.5rem 0.65rem;
            border: 1px solid var(--input);
            border-radius: 8px;
            font-size: 0.875rem;
            background: var(--background);
            color: var(--foreground);
            transition: border-color 0.2s ease;
            font-family: inherit;
            width: 100%;
        }
        
        .notes-add-form textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px hsla(var(--primary), 0.1);
        }
        
        .notes-add-form-row {
            display: flex;
            gap: 0.4rem;
            align-items: center;
            justify-content: space-between;
        }
        
        .notes-add-form-row .form-group.expiration-group {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0;
        }
        
        .notes-add-form-row .form-group.expiration-group label {
            margin-bottom: 0;
            font-size: 0.75rem;
            white-space: nowrap;
            color: var(--muted-foreground);
        }
        
        .notes-add-form-row .form-group.expiration-group select {
            padding: 0.3rem 0.5rem;
            font-size: 0.8rem;
            border: 1px solid var(--input);
            border-radius: 8px;
            background: var(--background);
            color: var(--foreground);
            cursor: pointer;
            transition: border-color 0.2s ease;
        }
        
        .notes-add-form-row .form-group.expiration-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px hsla(var(--primary), 0.1);
        }
        
        .notes-add-form-row .form-group.expiration-group input {
            width: 45px;
            padding: 0.3rem 0.35rem;
            font-size: 0.8rem;
            border: 1px solid var(--input);
            border-radius: 8px;
            background: var(--background);
            color: var(--foreground);
            text-align: center;
        }
        
        .notes-add-form-row .form-group.expiration-group input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px hsla(var(--primary), 0.1);
        }
        
        .notes-add-form-row .btn {
            padding: 0.45rem 1rem;
            font-size: 0.85rem;
            flex-shrink: 0;
            border-radius: 12px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--foreground);
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--muted-foreground);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: calc(var(--radius) - 2px);
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: var(--accent);
            color: var(--foreground);
        }
        
        .status-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 0.5rem;
            pointer-events: none;
        }
        
        .status {
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.875rem;
            max-width: 90%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            pointer-events: auto;
            font-weight: 500;
        }
        
        .status.success {
            background: hsl(142, 76%, 36%);
            color: hsl(0, 0%, 98%);
        }
        
        .status.error {
            background: var(--destructive);
            color: hsl(0, 0%, 98%);
        }
        
        .status.info {
            background: var(--primary);
            color: var(--primary-foreground);
        }
    </style>
</head>
<body>
    <!-- Header removed - navigation moved to bottom -->
    
    <!-- Map View -->
    <div class="view active" id="map-view">
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>
    
    
    <!-- Modals -->
    <div class="modal" id="onboarding-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Welcome to Nostroots</h2>
            </div>
            <p>You need a nostr key to get started. <strong>Recommended:</strong> Use a browser extension (your private key stays secure in the extension).</p>
            <div class="form-group" id="onboarding-nip07-section" style="display: none;">
                <button class="btn" onclick="onboardingConnectExtension()" style="width: 100%; margin-bottom: 0.5rem;">Connect Browser Extension (nos2x, Alby)</button>
                <p style="font-size: 0.75rem; color: var(--muted-foreground); margin-top: 0.5rem; text-align: center;">
                    Your private key never leaves the extension
                </p>
            </div>
            <div style="text-align: center; margin: 1rem 0; color: var(--muted-foreground);">or</div>
            <div class="form-group">
                <label>Import nsec (optional)</label>
                <input type="text" id="onboarding-nsec" placeholder="nsec1...">
            </div>
            <button class="btn" onclick="onboardingGenerate()">Generate New Key</button>
            <button class="btn btn-secondary" onclick="onboardingImport()">Import nsec</button>
        </div>
    </div>
    
    <div class="modal" id="view-note-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Note Details</h2>
                <button class="modal-close" onclick="closeViewNoteModal()">&times;</button>
            </div>
            <div id="note-details"></div>
        </div>
    </div>
    
    <!-- Plus Code Notes Modal -->
    <div class="modal" id="pluscode-notes-modal">
        <div class="modal-content notes-modal-content">
            <div class="modal-header">
                <h2 id="pluscode-notes-title">Notes</h2>
                <button class="modal-close" onclick="closePlusCodeNotesModal()">&times;</button>
            </div>
            <div id="pluscode-notes-content" class="notes-list"></div>
            <div class="notes-actions">
                <div class="notes-add-form">
                    <div class="notes-add-form-row">
                        <div class="form-group expiration-group">
                            <label>Expiration</label>
                            <select id="note-expiration-in-modal" onchange="saveExpirationSetting(this.value)">
                                <option value="31536000">1 year</option>
                                <option value="2592000">1 month</option>
                                <option value="604800" selected>1 week</option>
                                <option value="86400">1 day</option>
                                <option value="3600">1 hour</option>
                            </select>
                        </div>
                        <button id="circles-button-modal" class="circles-button" title="Select Trustroots Circle" onclick="showCirclesModal()">‚àû</button>
                    </div>
                    <textarea id="note-content-in-modal" rows="1" placeholder="Type a message... (Enter to send)" autofocus></textarea>
                    <div id="selected-circle-indicator-modal" style="display: none; margin-top: 4px; font-size: 0.85rem; color: var(--primary);">
                        <span id="selected-circle-text-modal"></span>
                        <button onclick="clearSelectedCircle('modal')" style="margin-left: 8px; background: none; border: none; color: var(--muted-foreground); cursor: pointer; font-size: 0.8rem;">‚úï</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Circles Modal -->
    <div class="modal" id="circles-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚àû Trustroots Circles</h2>
                <button class="modal-close" onclick="hideCirclesModal()">&times;</button>
            </div>
            <div class="form-group">
                <p style="margin-bottom: 16px; color: var(--muted-foreground); font-size: 0.9rem;">Select a circle to add to your note:</p>
                <div id="circles-list" class="circles-list">
                    <!-- Circles will be populated here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status Messages Container -->
    <div id="status-container" class="status-container"></div>
    
    <!-- Floating Settings Button -->
    <button class="settings-icon" id="settings-icon-btn" title="Settings">‚öôÔ∏è</button>
    
    <!-- Settings Modal -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            </div>
            <div class="settings-section">
                <h2>Keys</h2>
                
                <!-- Public Key Display -->
                <div class="form-group" id="npub-display-group" style="display: none;">
                    <label>Public Key (npub)</label>
                    <div class="key-input-wrapper">
                        <input type="text" id="npub-display" readonly>
                        <button class="copy-btn" id="copy-npub-btn" onclick="copyPublicKey()" title="Copy to clipboard">
                            <span id="copy-npub-text">üìã</span>
                        </button>
                    </div>
                </div>
                
                <div class="key-section-divider" id="key-section-divider" style="display: none;"></div>
                
                <!-- NIP-07 Status Indicator -->
                <div id="nip07-status" class="nip07-status"></div>
                
                <!-- Local Key Actions -->
                <div class="form-group" id="nsec-actions-group" style="display: none;">
                    <div class="action-buttons">
                        <button class="btn" onclick="exportNsec()">Export nsec</button>
                        <button class="btn btn-danger" onclick="deleteNsec()">Delete Key</button>
                    </div>
                </div>
                
                <!-- Import/Generate Section -->
                <div class="form-group" id="no-nsec-actions-group">
                    <label>Import nsec</label>
                    <input type="text" id="nsec-import" placeholder="nsec1...">
                    <button class="btn" onclick="importNsec()" style="margin-top: 0.5rem;">Import</button>
                </div>
                
                <div class="form-group" id="generate-key-group">
                    <button class="btn" id="generate-key-btn" onclick="generateKeyPair()">Generate New Key</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h2>Trustroots username</h2>
                <div class="form-group">
                    <input type="text" id="trustroots-username" placeholder="your-username" onkeydown="if(event.key === 'Enter') linkTrustrootsProfile()">
                    <div id="username-nostr-indicator" class="username-nostr-indicator" style="display: none;">
                        <small>This username is from a Nostr event and cannot be edited here.</small>
                    </div>
                    <button class="btn" id="link-profile-btn" onclick="linkTrustrootsProfile()">Link Profile</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h2>Relays</h2>
                <div id="relays-list" class="relays-list"></div>
                <div class="form-group" style="margin-top: 1rem;">
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" id="new-relay-url" placeholder="wss://relay.example.com" style="flex: 1;" onkeydown="if(event.key === 'Enter') addRelay()">
                        <button class="btn" onclick="addRelay()">Add Relay</button>
                    </div>
                </div>
            </div>
            
            <a href="https://github.com/Trustroots/nostroots/tree/main/nr-web" target="_blank" rel="noopener noreferrer" class="github-icon-link">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
            </a>
        </div>
    </div>
    
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.js"></script>
    
    <!-- Suppress WebGL deprecation warning from MapLibre GL -->
    <script>
        // Filter out the harmless WebGL deprecation warning from MapLibre GL JS
        const originalWarn = console.warn;
        console.warn = function(...args) {
            const message = args.join(' ');
            // Suppress the specific WebGL texture upload deprecation warning
            if (message.includes('texImage') && 
                (message.includes('Alpha-premult') || message.includes('y-flip'))) {
                return; // Suppress this specific warning
            }
            // Pass through all other warnings
            originalWarn.apply(console, args);
        };
    </script>
    
    <script type="module">
        // Import nostr-tools for crypto operations
        import { 
            finalizeEvent, 
            getPublicKey, 
            nip19,
            Relay 
        } from 'https://cdn.jsdelivr.net/npm/nostr-tools@2.10.3/+esm';
        
        // NDK is not loaded from CDN due to CORS/MIME type issues
        // We use nostr-tools Relay directly instead, which works reliably
        const NDK = null;
        
        // Constants from nr-common
        const MAP_NOTE_KIND = 30397;
        const MAP_NOTE_REPOST_KIND = 30398;
        const DELETION_KIND = 5; // NIP-05: Deletion events
        const TRUSTROOTS_PROFILE_KIND = 10390;
        const TRUSTROOTS_USERNAME_LABEL_NAMESPACE = "org.trustroots:username";
        const DEFAULT_RELAY_URL = 'wss://relay.trustroots.org';
        const DEFAULT_RELAYS = ['wss://relay.trustroots.org', 'wss://relay.nomadwiki.org'];
        const DERIVED_EVENT_PLUS_CODE_PREFIX_MINIMUM_LENGTH = 2;
        
        const NOSTROOTS_VALIDATION_PUBKEY = 'f5bc71692fc08ea52c0d1c8bcfb87579584106b5feb4ea542b1b8a95612f257b';
        const DEV_PUBKEY = '80789235a71a388074abfa5c482e270456d2357425266270f82071cf2b1de74a';
        
        // Map to store pubkey -> Trustroots username
        const pubkeyToUsername = new Map();
        
        const MAP_LAYERS = {
            trustroots: {
                title: 'Trustroots',
                filter: { kinds: [MAP_NOTE_KIND] }, // Only kind 30397 (map notes)
                kind: MAP_NOTE_KIND,
                pubkey: NOSTROOTS_VALIDATION_PUBKEY,
                markerColor: 'green',
                rectangleColor: 'grey'
            }
        };
        
        // Global state
        let ndk = null;
        let relays = [];
        let map = null;
        let markers = [];
        let events = [];
        let selectedPlusCode = null;
        let selectedCircle = null; // Selected Trustroots circle slug
        let isDragging = false; // Track dragging state to prevent grid updates during drag
        let pendingGridUpdate = false; // Track if grid update is needed after drag ends
        let currentPrivateKey = null;
        let currentPrivateKeyBytes = null;
        let currentPublicKey = null;
        let usingNip07 = false;
        let nostrProvider = null;
        let authenticatingWithExtension = false; // Guard to prevent concurrent calls
        let isProfileLinked = false; // Track if profile is NIP-5 linked
        let usernameFromNostr = false; // Track if username came from a Nostr event
        
        // Caching and performance optimization state
        const EVENTS_CACHE_KEY = 'nostroots_events_cache';
        const EVENTS_CACHE_TIMESTAMP_KEY = 'nostroots_events_cache_timestamp';
        const CACHE_MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        const EXPIRATION_SETTING_KEY = 'nostroots_expiration_seconds';
        let cachedFilteredEvents = null;
        let filteredEventsCacheKey = null;
        let localStorageWriteTimeout = null;
        let gridUpdateAnimationFrame = null;
        
        // Expiration constants (matching nr-app)
        const MINUTE_IN_SECONDS = 60;
        const HOUR_IN_SECONDS = 60 * MINUTE_IN_SECONDS;
        const DAY_IN_SECONDS = 24 * HOUR_IN_SECONDS;
        const WEEK_IN_SECONDS = 7 * DAY_IN_SECONDS;
        const MONTH_IN_SECONDS = 30 * DAY_IN_SECONDS;
        const YEAR_IN_SECONDS = 365 * DAY_IN_SECONDS;
        
        // Spatial indexing for fast event lookups
        let eventsByPlusCode = new Map(); // Map<plusCode, Set<event>>
        let eventsByPlusCodePrefix = new Map(); // Map<prefix, Set<event>> for "within" queries
        let rectangleCache = new Map(); // Map<plusCode, rectangle>
        const MAX_GRID_FEATURES = 2000; // Limit number of grid cells rendered
        
        // Plus Code encoding/decoding using Open Location Code algorithm
        const PLUS_CODE_ALPHABET = '23456789CFGHJMPQRVWX';
        const CODE_ALPHABET_LENGTH = PLUS_CODE_ALPHABET.length;
        const GRID_SIZE = 20;
        const PAIR_RESOLUTIONS = [20.0, 1.0, 0.05, 0.0025, 0.000125];
        const LATITUDE_MAX = 90;
        const LONGITUDE_MAX = 180;
        
        // Normalize longitude to -180 to 180 range
        function normalizeLongitude(lng) {
            while (lng > LONGITUDE_MAX) lng -= 360;
            while (lng < -LONGITUDE_MAX) lng += 360;
            return lng;
        }
        
        function encodePlusCode(latitude, longitude, codeLength = 10) {
            // Normalize longitude to -180 to 180 range (handles map wrapping)
            longitude = normalizeLongitude(longitude);
            
            if (latitude < -LATITUDE_MAX || latitude > LATITUDE_MAX || 
                longitude < -LONGITUDE_MAX || longitude > LONGITUDE_MAX) {
                return null;
            }
            
            // Normalize coordinates for encoding
            let lat = latitude + LATITUDE_MAX;
            let lng = longitude + LONGITUDE_MAX;
            
            let code = '';
            let resolution = 400;
            
            // Encode pairs (codeLength 2 = 1 pair, 4 = 2 pairs, etc.)
            const numPairs = Math.ceil(codeLength / 2);
            for (let i = 0; i < numPairs; i++) {
                if (i < PAIR_RESOLUTIONS.length) {
                    resolution = PAIR_RESOLUTIONS[i];
                } else {
                    // For pairs beyond PAIR_RESOLUTIONS, calculate resolution
                    const pairIndex = i;
                    resolution = PAIR_RESOLUTIONS[PAIR_RESOLUTIONS.length - 1] / Math.pow(GRID_SIZE, pairIndex - PAIR_RESOLUTIONS.length + 1);
                }
                
                const latDigit = Math.min(PLUS_CODE_ALPHABET.length - 1, Math.floor(lat / resolution));
                const lngDigit = Math.min(PLUS_CODE_ALPHABET.length - 1, Math.floor(lng / resolution));
                
                code += PLUS_CODE_ALPHABET[latDigit];
                code += PLUS_CODE_ALPHABET[lngDigit];
                
                lat -= latDigit * resolution;
                lng -= lngDigit * resolution;
            }
            
            // Pad short codes with zeros and add separator
            if (code.length < 8) {
                code = code.padEnd(8, '0');
            }
            code = code.substring(0, 8) + '+' + code.substring(8);
            
            return code;
        }
        
        function decodePlusCode(code) {
            if (!code || code.length < 2) return null;
            
            // Remove separator
            let cleanCode = code.replace('+', '').toUpperCase();
            
            let lat = -LATITUDE_MAX;
            let lng = -LONGITUDE_MAX;
            let resolution = 400;
            let lastResolution = 400;
            
            // Decode pairs - stop at zeros (padding) or end of code
            for (let i = 0; i < Math.min(cleanCode.length, 10); i += 2) {
                if (i + 1 >= cleanCode.length) break;
                
                const latChar = cleanCode[i];
                const lngChar = cleanCode[i + 1];
                
                // Stop at zeros - they indicate padding
                if (latChar === '0' || lngChar === '0') break;
                
                const latIndex = PLUS_CODE_ALPHABET.indexOf(latChar);
                const lngIndex = PLUS_CODE_ALPHABET.indexOf(lngChar);
                
                if (latIndex === -1 || lngIndex === -1) return null;
                
                if (Math.floor(i / 2) < PAIR_RESOLUTIONS.length) {
                    resolution = PAIR_RESOLUTIONS[Math.floor(i / 2)];
                } else {
                    // For pairs beyond PAIR_RESOLUTIONS, calculate resolution
                    const pairIndex = Math.floor(i / 2);
                    resolution = PAIR_RESOLUTIONS[PAIR_RESOLUTIONS.length - 1] / Math.pow(GRID_SIZE, pairIndex - PAIR_RESOLUTIONS.length + 1);
                }
                lastResolution = resolution;
                
                lat += latIndex * resolution;
                lng += lngIndex * resolution;
            }
            
            // Return center of the code area (southwest corner + half resolution)
            return { 
                latitude: lat + lastResolution / 2, 
                longitude: lng + lastResolution / 2 
            };
        }
        
        function plusCodeToRectangle(plusCode) {
            // Check cache first
            if (rectangleCache.has(plusCode)) {
                return rectangleCache.get(plusCode);
            }
            
            const decoded = decodePlusCode(plusCode);
            if (!decoded) return null;
            
            // Get the resolution for this plus code length
            // Count only significant (non-zero, non-padding) characters
            const cleanCode = plusCode.replace('+', '').toUpperCase();
            let significantLength = cleanCode.length;
            for (let i = 0; i < cleanCode.length; i++) {
                if (cleanCode[i] === '0') {
                    significantLength = i;
                    break;
                }
            }
            const pairCount = Math.floor(significantLength / 2);
            let resolution = 20.0; // Default for 2-character codes (1 pair)
            if (pairCount > 0 && pairCount <= PAIR_RESOLUTIONS.length) {
                resolution = PAIR_RESOLUTIONS[pairCount - 1];
            } else if (pairCount > PAIR_RESOLUTIONS.length) {
                resolution = PAIR_RESOLUTIONS[PAIR_RESOLUTIONS.length - 1] / Math.pow(GRID_SIZE, pairCount - PAIR_RESOLUTIONS.length);
            }
            
            // decoded is now the center, so we need half resolution on each side
            const halfLatRes = resolution / 2;
            const halfLngRes = resolution / 2;
            
            // Return as [lng, lat] pairs for GeoJSON
            const rectangle = [
                [decoded.longitude - halfLngRes, decoded.latitude - halfLatRes],
                [decoded.longitude + halfLngRes, decoded.latitude - halfLatRes],
                [decoded.longitude + halfLngRes, decoded.latitude + halfLatRes],
                [decoded.longitude - halfLngRes, decoded.latitude + halfLatRes],
                [decoded.longitude - halfLngRes, decoded.latitude - halfLatRes] // Close the polygon
            ];
            
            // Cache the result, but limit cache size to prevent memory issues
            if (rectangleCache.size > 10000) {
                // Clear oldest entries (simple FIFO - clear all and let it rebuild)
                rectangleCache.clear();
            }
            rectangleCache.set(plusCode, rectangle);
            return rectangle;
        }
        
        // Build spatial index for fast event lookups
        function rebuildSpatialIndex() {
            eventsByPlusCode.clear();
            eventsByPlusCodePrefix.clear();
            
            const enabledLayers = getEnabledLayers();
            let indexedCount = 0;
            let skippedExpired = 0;
            let skippedDeleted = 0;
            let skippedDeletionKind = 0;
            let skippedNoLayer = 0;
            let skippedNoPlusCode = 0;
            
            events.forEach(event => {
                // Skip expired events - they shouldn't be indexed
                if (isEventExpired(event)) {
                    skippedExpired++;
                    return;
                }
                
                // Skip deleted events - they shouldn't be indexed
                if (isEventDeleted(event)) {
                    skippedDeleted++;
                    return;
                }
                
                // Skip deletion events themselves - they shouldn't be indexed
                if (event.kind === DELETION_KIND) {
                    skippedDeletionKind++;
                    return;
                }
                
                const layer = getLayerForEvent(event);
                if (!layer || !enabledLayers.includes(layer)) {
                    skippedNoLayer++;
                    return;
                }
                
                const eventPlusCode = getPlusCodeFromEvent(event);
                if (!eventPlusCode) {
                    skippedNoPlusCode++;
                    return;
                }
                
                // Index by exact plus code
                if (!eventsByPlusCode.has(eventPlusCode)) {
                    eventsByPlusCode.set(eventPlusCode, new Set());
                }
                eventsByPlusCode.get(eventPlusCode).add(event);
                
                // Index by prefixes for "within" queries
                const cleanCode = eventPlusCode.replace('+', '').toUpperCase();
                for (let len = 2; len <= Math.min(8, cleanCode.length); len += 2) {
                    const prefix = cleanCode.substring(0, len).padEnd(8, '0') + '+';
                    if (!eventsByPlusCodePrefix.has(prefix)) {
                        eventsByPlusCodePrefix.set(prefix, new Set());
                    }
                    eventsByPlusCodePrefix.get(prefix).add(event);
                }
                
                indexedCount++;
            });
            
            // Debug: Uncomment to see spatial index rebuild stats
            // console.log('[rebuildSpatialIndex]', {
            //     totalEvents: events.length,
            //     indexed: indexedCount,
            //     skippedExpired: skippedExpired,
            //     skippedDeleted: skippedDeleted,
            //     skippedDeletionKind: skippedDeletionKind,
            //     skippedNoLayer: skippedNoLayer,
            //     skippedNoPlusCode: skippedNoPlusCode
            // });
        }
        
        // Fast lookup using spatial index
        function filterEventsForPlusCodeFast(plusCode) {
            const eventsForPlusCodeExactly = Array.from(eventsByPlusCode.get(plusCode) || [])
                .filter(event => !isEventDeleted(event) && !isEventExpired(event) && event.kind !== DELETION_KIND);
            
            // For "within" queries, events that are inside this plus code have longer codes
            // We need to check all events indexed by prefixes that start with this plus code
            const eventsWithinPlusCode = [];
            const cleanCode = plusCode.replace('+', '').toUpperCase();
            const indexOfFirstZero = cleanCode.indexOf("0");
            const searchPrefix = indexOfFirstZero === -1 ? cleanCode : cleanCode.substring(0, indexOfFirstZero);
            
            // Check all prefixes that start with our search prefix (longer codes)
            eventsByPlusCodePrefix.forEach((eventSet, prefix) => {
                const prefixClean = prefix.replace('+', '').toUpperCase();
                // If the prefix is longer and starts with our search prefix, check events
                if (prefixClean.length > searchPrefix.length && prefixClean.startsWith(searchPrefix)) {
                    eventSet.forEach(event => {
                        // Filter out deleted, expired, and deletion events
                        if (isEventDeleted(event) || isEventExpired(event) || event.kind === DELETION_KIND) {
                            return;
                        }
                        const eventPlusCode = getPlusCodeFromEvent(event);
                        if (eventPlusCode && eventPlusCode !== plusCode && isPlusCodeInsidePlusCode(plusCode, eventPlusCode)) {
                            // Avoid duplicates
                            if (!eventsWithinPlusCode.includes(event)) {
                                eventsWithinPlusCode.push(event);
                            }
                        }
                    });
                }
            });
            
            return { eventsForPlusCodeExactly, eventsWithinPlusCode };
        }
        
        function whatLengthOfPlusCodeToShow(latitudeDelta, longitudeDelta = latitudeDelta * 2) {
            // Calculate the best code length based on expected cell count
            // We want total cells < MAX_GRID_FEATURES to avoid cutoff
            const maxCells = MAX_GRID_FEATURES * 0.8; // Use 80% of limit for safety margin
            
            // Cell sizes for each code length (ordered from finest to coarsest)
            const codeLengths = [
                { length: 8, cellSize: 0.0025 },
                { length: 6, cellSize: 0.05 },
                { length: 4, cellSize: 1.0 },
                { length: 2, cellSize: 20.0 }
            ];
            
            // Find the finest resolution that stays under the cell limit
            for (const { length, cellSize } of codeLengths) {
                const latSteps = Math.ceil(latitudeDelta / cellSize) + 1;
                const lngSteps = Math.ceil(longitudeDelta / cellSize) + 1;
                const totalCells = latSteps * lngSteps;
                
                if (totalCells <= maxCells) {
                    return length;
                }
            }
            
            // Fallback to coarsest
            return 2;
        }
        
        function degreeSizeForPlusCodeLength(length) {
            // Match nr-app implementation
            if (length === 2) return 20.0;
            if (length === 4) return 1.0;
            if (length === 6) return 0.05;
            if (length === 8) return 0.0025;
            // For longer codes, calculate based on grid size
            return 0.0025 / Math.pow(GRID_SIZE, (length - 8) / 2);
        }
        
        function getAllPlusCodesBetweenTwoPlusCodes(southWest, northEast, length) {
            if (southWest.length > 9 || northEast.length > 9) {
                console.error('Plus code too long');
                return [];
            }
            
            const swDecoded = decodePlusCode(southWest);
            const neDecoded = decodePlusCode(northEast);
            if (!swDecoded || !neDecoded) {
                return [];
            }
            
            let latitudeDelta = neDecoded.latitude - swDecoded.latitude;
            let longitudeDelta = neDecoded.longitude - swDecoded.longitude;
            
            // Handle negative longitude delta (when coordinates wrap)
            if (longitudeDelta < 0) {
                longitudeDelta += 360;
            }
            
            const degreesPerStep = degreeSizeForPlusCodeLength(length);
            
            // Use ceil + 1 to ensure we include the NE boundary
            const latitudeSteps = Math.max(1, Math.ceil(latitudeDelta / degreesPerStep) + 1);
            const longitudeSteps = Math.max(1, Math.ceil(longitudeDelta / degreesPerStep) + 1);
            
            const plusCodes = [];
            for (let latIndex = 0; latIndex < latitudeSteps; latIndex++) {
                for (let lngIndex = 0; lngIndex < longitudeSteps; lngIndex++) {
                    const latitude = swDecoded.latitude + latIndex * degreesPerStep;
                    let longitude = swDecoded.longitude + lngIndex * degreesPerStep;
                    // Normalize longitude
                    longitude = normalizeLongitude(longitude);
                    const plusCode = encodePlusCode(latitude, longitude, length);
                    if (plusCode) {
                        plusCodes.push(plusCode);
                    }
                }
            }
            
            return plusCodes;
        }
        
        function allPlusCodesForRegion(bounds, codeLength) {
            const sw = encodePlusCode(bounds.south, bounds.west, codeLength);
            const ne = encodePlusCode(bounds.north, bounds.east, codeLength);
            if (!sw || !ne) return [];
            return getAllPlusCodesBetweenTwoPlusCodes(sw, ne, codeLength);
        }
        
        // Check if one plus code is inside another (matches nr-common logic)
        function isPlusCodeInsidePlusCode(containingPlusCode, targetPlusCode) {
            const indexOfFirstZero = containingPlusCode.indexOf("0");
            // If the plus code has a trailing zero, use the code up to that as a search
            // prefix, otherwise use the whole code
            const startsWithPrefix = indexOfFirstZero === -1
                ? containingPlusCode
                : containingPlusCode.slice(0, indexOfFirstZero);
            const isWithin = targetPlusCode.startsWith(startsWithPrefix);
            return isWithin;
        }
        
        function filterEventsForPlusCode(eventList, plusCode) {
            const eventsForPlusCodeExactly = [];
            const eventsWithinPlusCode = [];
            
            eventList.forEach(event => {
                const eventPlusCode = getPlusCodeFromEvent(event);
                if (!eventPlusCode) return;
                
                if (eventPlusCode === plusCode) {
                    eventsForPlusCodeExactly.push(event);
                } else if (isPlusCodeInsidePlusCode(plusCode, eventPlusCode)) {
                    // Event's plus code is within the containing plus code
                    eventsWithinPlusCode.push(event);
                }
            });
            
            return { eventsForPlusCodeExactly, eventsWithinPlusCode };
        }
        
        function getTrustrootsCircles() {
            return [
                { slug: 'hitch' },
                { slug: 'dumpsterdivers' },
                { slug: 'families' },
                { slug: 'musicians' },
                { slug: 'buskers' },
                { slug: 'veg' },
                { slug: 'hackers' },
                { slug: 'lgbtq' },
                { slug: 'ecoliving' },
                { slug: 'lindyhoppers' },
                { slug: 'nomads' },
                { slug: 'punks' },
                { slug: 'cyclists' },
                { slug: 'foodsharing' },
                { slug: 'yoga' },
                { slug: 'climbers' },
                { slug: 'hikers' },
                { slug: 'sailors' },
                { slug: 'artists' },
                { slug: 'rainbowgathering' },
                { slug: 'slackline' },
                { slug: 'spirituals' },
                { slug: 'dancers' },
                { slug: 'acroyoga' },
                { slug: 'jugglers' },
                { slug: 'vanlife' },
                { slug: 'volunteers' },
                { slug: 'winemakers' },
                { slug: 'squatters' },
                { slug: 'surfers' },
                { slug: 'skateboarders' },
                { slug: 'pilgrims' },
                { slug: 'photographers' },
                { slug: 'naturists' },
                { slug: 'motorcyclists' },
                { slug: 'feminists' },
                { slug: 'circus' },
                { slug: 'cooking' },
                { slug: 'burners' },
                { slug: 'beerbrewers' },
                { slug: 'anarchists' },
                { slug: 'gardeners' },
                { slug: 'scubadivers' },
                { slug: 'ravers' },
                { slug: 'zero-wasters' },
                { slug: 'activists' },
                { slug: 'runners' },
                { slug: 'filmmakers' },
                { slug: 'books' },
                { slug: 'cypherpunks' },
                { slug: 'lightfoot' }
            ];
        }
        
        function getPlusCodePrefixes(plusCode, minimumLength = 2) {
            const prefixes = [];
            const cleanCode = plusCode.split('+')[0];
            const maxLength = Math.min(8, cleanCode.length);
            
            for (let len = minimumLength; len <= maxLength; len += 2) {
                const prefix = cleanCode.substring(0, len).padEnd(8, '0') + '+';
                prefixes.push(prefix);
            }
            
            return [...new Set(prefixes)];
        }
        
        // NIP-07 Extension Support
        function detectNostrExtension() {
            // Check for standard window.nostr interface (nos2x, etc.)
            if (window.nostr && typeof window.nostr.getPublicKey === 'function') {
                return window.nostr;
            }
            
            // Check for Alby's nostr provider
            if (window.webln && window.webln.nostr && typeof window.webln.nostr.getPublicKey === 'function') {
                return window.webln.nostr;
            }
            
            return null;
        }
        
        // Helper to check if extension is actually ready (not just detected)
        function isExtensionReady(provider) {
            if (!provider) return false;
            if (typeof provider.getPublicKey !== 'function') return false;
            // Some extensions might have additional readiness checks
            // For now, just check if the function exists and is callable
            return true;
        }
        
        async function authenticateWithExtension() {
            // Prevent concurrent calls
            if (authenticatingWithExtension) {
                return false;
            }
            
            authenticatingWithExtension = true;
            
            try {
                const provider = detectNostrExtension();
                
                if (!provider) {
                    showStatus('No NIP-07 extension found. Please install nos2x or Alby.', 'error');
                    authenticatingWithExtension = false;
                    return false;
                }
                
                // Validate that getPublicKey is a function before calling
                if (!isExtensionReady(provider)) {
                    showStatus('Extension getPublicKey method is not available or not ready', 'error');
                    authenticatingWithExtension = false;
                    return false;
                }
                
                // Get public key from extension - call with no arguments explicitly
                // NIP-07 spec: getPublicKey() should be called with no arguments
                // Some extensions may throw errors if called incorrectly or if not ready
                let pubkey;
                let callError = null;
                
                try {
                    pubkey = await provider.getPublicKey();
                } catch (error) {
                    callError = error;
                    console.error('Error calling getPublicKey (first attempt):', error);
                    
                    // Check if this is the known SyntaxError from the extension's content script
                    // This is a bug in some extensions where they throw SyntaxError internally
                    const errorStr = String(error?.message || error?.toString() || '');
                    const isSyntaxError = error?.name === 'SyntaxError' || 
                                         errorStr.includes('SyntaxError') ||
                                         errorStr.includes('invalid or illegal string');
                    
                    if (isSyntaxError) {
                        // This is likely an extension bug - wait longer and retry
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        // Re-check that extension is still available
                        const retryProvider = detectNostrExtension();
                        
                        if (!retryProvider || !isExtensionReady(retryProvider)) {
                            throw new Error('Extension error: The extension encountered an internal error. Please try refreshing the page, or unlock/restart your extension and try again.');
                        }
                        
                        try {
                            pubkey = await retryProvider.getPublicKey();
                            callError = null; // Success on retry
                        } catch (retryError) {
                            console.error('Error calling getPublicKey (retry attempt):', retryError);
                            // Still failing - provide helpful error message
                            throw new Error('Extension error: The extension is having issues. Please try: 1) Unlock your extension, 2) Refresh this page, or 3) Restart your browser. If the problem persists, the extension may need to be updated.');
                        }
                    } else {
                        // Other types of errors - wait a bit and retry once
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Re-check that extension is still available
                        const retryProvider = detectNostrExtension();
                        if (!retryProvider || !isExtensionReady(retryProvider)) {
                            throw new Error('Extension became unavailable. Please ensure the extension is installed and enabled, then try again.');
                        }
                        
                        try {
                            pubkey = await retryProvider.getPublicKey();
                            callError = null; // Success on retry
                        } catch (retryError) {
                            console.error('Error calling getPublicKey (retry attempt):', retryError);
                            const errorMsg = callError?.message || callError?.toString() || 'Unknown error';
                            throw new Error(`Extension getPublicKey failed: ${errorMsg}. Please ensure the extension is unlocked and try again.`);
                        }
                    }
                }
                
                // If we still have an error after retries, throw it
                if (callError && !pubkey) {
                    throw callError;
                }
                
                // Validate the returned public key
                if (!pubkey || typeof pubkey !== 'string') {
                    showStatus('Failed to get public key from extension: invalid response', 'error');
                    authenticatingWithExtension = false;
                    return false;
                }
                
                // Validate it's a valid hex string (64 chars for 32 bytes)
                if (!/^[0-9a-f]{64}$/i.test(pubkey)) {
                    showStatus('Extension returned invalid public key format', 'error');
                    authenticatingWithExtension = false;
                    return false;
                }
                
                // IMPORTANT: With NIP-07, the private key NEVER leaves the extension
                // We explicitly clear any local private keys and only store the public key
                currentPrivateKey = null;
                currentPrivateKeyBytes = null;
                localStorage.removeItem('nostr_private_key');
                
                // Store provider and public key only
                nostrProvider = provider;
                currentPublicKey = pubkey;
                usingNip07 = true;
                
                // Save preference
                localStorage.setItem('using_nip07', 'true');
                
                updateKeyDisplay();
                showStatus('Connected to NIP-07 extension! Your private key stays secure in the extension.', 'success');
                authenticatingWithExtension = false;
                return true;
            } catch (error) {
                console.error('Error authenticating with extension:', error);
                // Provide more specific error messages
                let errorMsg = 'Error connecting to extension';
                if (error.message) {
                    errorMsg += ': ' + error.message;
                } else if (error.toString && error.toString() !== '[object Object]') {
                    errorMsg += ': ' + error.toString();
                }
                showStatus(errorMsg, 'error');
                usingNip07 = false;
                nostrProvider = null;
                authenticatingWithExtension = false;
                return false;
            }
        }
        
        function toggleNip07() {
            // This function is kept for compatibility but is no longer called
            // since the checkbox was removed. NIP-07 is now managed automatically
            // through authenticateWithExtension() and can be disabled by generating/importing keys.
        }
        
        function checkNip07OnLoad() {
            // Give extension content script time to initialize
            // Some extensions need a moment to inject their content script
            setTimeout(() => {
                // Check if extension is available
                const provider = detectNostrExtension();
                const nip07Section = document.getElementById('nip07-section');
                const onboardingNip07Section = document.getElementById('onboarding-nip07-section');
                
                if (provider) {
                    if (nip07Section) nip07Section.style.display = 'block';
                    if (onboardingNip07Section) onboardingNip07Section.style.display = 'block';
                    
                    // Note: We don't auto-reconnect here to avoid conflicts with checkOnboarding()
                    // The checkOnboarding() function will handle reconnection if needed
                } else {
                    if (nip07Section) nip07Section.style.display = 'none';
                    if (onboardingNip07Section) onboardingNip07Section.style.display = 'none';
                    
                    // If extension was previously used but is now unavailable, clear preference
                    const wasUsingNip07 = localStorage.getItem('using_nip07') === 'true';
                    if (wasUsingNip07) {
                        localStorage.removeItem('using_nip07');
                        usingNip07 = false;
                        nostrProvider = null;
                    }
                }
            }, 200);
        }
        
        // Key management
        function generateKeyPair() {
            // Disable NIP-07 when generating new key
            usingNip07 = false;
            nostrProvider = null;
            localStorage.removeItem('using_nip07');
            
            const privateKey = new Uint8Array(32);
            crypto.getRandomValues(privateKey);
            const privateKeyHex = Array.from(privateKey).map(b => b.toString(16).padStart(2, '0')).join('');
            savePrivateKey(privateKeyHex);
            loadKeys();
            showStatus('New key pair generated!', 'success');
        }
        
        async function importNsec() {
            // Disable NIP-07 when importing nsec
            usingNip07 = false;
            nostrProvider = null;
            localStorage.removeItem('using_nip07');
            
            const nsecInput = document.getElementById('nsec-import').value.trim();
            if (!nsecInput) {
                showStatus('Please enter an nsec', 'error');
                return;
            }
            
            try {
                const privateKeyHex = decodeNsec(nsecInput);
                if (privateKeyHex) {
                    savePrivateKey(privateKeyHex);
                    loadKeys();
                    showStatus('nsec imported successfully!', 'success');
                    document.getElementById('nsec-import').value = '';
                } else {
                    showStatus('Invalid nsec format', 'error');
                }
            } catch (error) {
                showStatus('Error importing nsec: ' + error.message, 'error');
            }
        }
        
        function decodeNsec(nsec) {
            if (!nsec.startsWith('nsec1')) return null;
            
            try {
                const decoded = nip19.decode(nsec);
                if (decoded.type === 'nsec') {
                    const bytes = decoded.data;
                    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
                }
                return null;
            } catch (error) {
                console.error('Error decoding nsec:', error);
                return null;
            }
        }
        
        function savePrivateKey(privateKeyHex) {
            // When saving a local private key, disable NIP-07
            // NIP-07 and local keys are mutually exclusive
            if (usingNip07) {
                usingNip07 = false;
                nostrProvider = null;
                localStorage.removeItem('using_nip07');
            }
            
            localStorage.setItem('nostr_private_key', privateKeyHex);
            currentPrivateKey = privateKeyHex;
            
            // Convert to bytes and derive public key
            const bytes = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                bytes[i] = parseInt(privateKeyHex.substring(i * 2, i * 2 + 2), 16);
            }
            currentPrivateKeyBytes = bytes;
            currentPublicKey = getPublicKey(bytes);
        }
        
        function loadKeys() {
            const privateKeyHex = localStorage.getItem('nostr_private_key');
            if (privateKeyHex) {
                savePrivateKey(privateKeyHex); // This will also derive public key
            }
            updateKeyDisplay();
        }
        
        function copyPublicKey() {
            const npubDisplay = document.getElementById('npub-display');
            const copyBtn = document.getElementById('copy-npub-btn');
            const copyText = document.getElementById('copy-npub-text');
            
            if (!npubDisplay || !npubDisplay.value) {
                showStatus('No public key to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(npubDisplay.value).then(() => {
                // Visual feedback
                const originalText = copyText.textContent;
                copyText.textContent = '‚úì';
                copyBtn.classList.add('copied');
                
                showStatus('Public key copied to clipboard!', 'success');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyText.textContent = originalText;
                    copyBtn.classList.remove('copied');
                }, 2000);
            }).catch(() => {
                showStatus('Failed to copy to clipboard', 'error');
            });
        }
        
        function exportNsec() {
            if (!currentPrivateKey) {
                showStatus('No private key to export', 'error');
                return;
            }
            
            try {
                // Convert hex to bytes
                const bytes = new Uint8Array(32);
                for (let i = 0; i < 32; i++) {
                    bytes[i] = parseInt(currentPrivateKey.substring(i * 2, i * 2 + 2), 16);
                }
                
                // Encode as nsec
                const nsec = nip19.nsecEncode(bytes);
                
                // Copy to clipboard
                navigator.clipboard.writeText(nsec).then(() => {
                    showStatus('nsec copied to clipboard!', 'success');
                }).catch(() => {
                    // Fallback: show in alert if clipboard API fails
                    prompt('Your nsec (copy this):', nsec);
                    showStatus('nsec displayed', 'info');
                });
            } catch (error) {
                console.error('Error exporting nsec:', error);
                showStatus('Error exporting nsec: ' + error.message, 'error');
            }
        }
        
        function deleteNsec() {
            // This function only applies to local keys, not NIP-07
            if (usingNip07) {
                showStatus('Cannot delete extension key. Disable NIP-07 first if you want to use local keys.', 'error');
                return;
            }
            
            if (!confirm('Are you sure you want to delete your private key? This action cannot be undone. You will need to import or generate a new key to continue using the app.')) {
                return;
            }
            
            localStorage.removeItem('nostr_private_key');
            currentPrivateKey = null;
            currentPrivateKeyBytes = null;
            currentPublicKey = null;
            isProfileLinked = false;
            usernameFromNostr = false;
            
            // Reset username field
            const usernameInput = document.getElementById('trustroots-username');
            const usernameIndicator = document.getElementById('username-nostr-indicator');
            if (usernameInput) {
                usernameInput.value = '';
                usernameInput.disabled = false;
            }
            if (usernameIndicator) {
                usernameIndicator.style.display = 'none';
            }
            
            updateKeyDisplay();
            document.getElementById('npub-display').value = '';
            showStatus('Private key deleted', 'success');
            
            // Show onboarding modal again
            document.getElementById('onboarding-modal').classList.add('active');
        }
        
        function updateKeyDisplay() {
            const hasNsec = !!currentPrivateKey;
            const nsecActionsGroup = document.getElementById('nsec-actions-group');
            const noNsecActionsGroup = document.getElementById('no-nsec-actions-group');
            const generateKeyBtn = document.getElementById('generate-key-btn');
            const generateKeyGroup = document.getElementById('generate-key-group');
            const linkProfileBtn = document.getElementById('link-profile-btn');
            const nip07Status = document.getElementById('nip07-status');
            
            if (usingNip07) {
                // Using NIP-07 - hide nsec actions, show that we're using extension
                // IMPORTANT: With NIP-07, we never have access to the private key
                if (nsecActionsGroup) nsecActionsGroup.style.display = 'none';
                if (noNsecActionsGroup) noNsecActionsGroup.style.display = 'none';
                if (generateKeyGroup) generateKeyGroup.style.display = 'none';
                // Enable link profile button when using NIP-07 (extension provides signing)
                if (linkProfileBtn) linkProfileBtn.disabled = false;
                // Show NIP-07 status
                if (nip07Status) {
                    nip07Status.textContent = '‚úì Using NIP-07 browser extension - private key secure in extension';
                    nip07Status.classList.add('show');
                }
            } else {
                // Not using NIP-07 - show/hide based on whether we have local keys
                if (nip07Status) nip07Status.classList.remove('show');
                
                if (hasNsec) {
                    // Show export/delete buttons, hide import/generate
                    if (nsecActionsGroup) nsecActionsGroup.style.display = 'block';
                    if (noNsecActionsGroup) noNsecActionsGroup.style.display = 'none';
                    if (generateKeyGroup) generateKeyGroup.style.display = 'none';
                    // Enable link profile button when we have nsec
                    if (linkProfileBtn) linkProfileBtn.disabled = false;
                } else {
                    // Show import/generate buttons, hide export/delete
                    if (nsecActionsGroup) nsecActionsGroup.style.display = 'none';
                    if (noNsecActionsGroup) noNsecActionsGroup.style.display = 'block';
                    if (generateKeyGroup) generateKeyGroup.style.display = 'block';
                    // Disable link profile button when there's no nsec
                    if (linkProfileBtn) linkProfileBtn.disabled = true;
                }
            }
            
            // Show/hide public key field based on whether we have a public key
            const npubDisplayGroup = document.getElementById('npub-display-group');
            const keySectionDivider = document.getElementById('key-section-divider');
            
            if (currentPublicKey) {
                try {
                    // nip19.npubEncode expects hex string
                    const npub = nip19.npubEncode(currentPublicKey);
                    document.getElementById('npub-display').value = npub;
                    if (npubDisplayGroup) npubDisplayGroup.style.display = 'block';
                    if (keySectionDivider) keySectionDivider.style.display = 'block';
                } catch (error) {
                    console.error('Error encoding npub:', error);
                    document.getElementById('npub-display').value = 'Error encoding npub';
                    if (npubDisplayGroup) npubDisplayGroup.style.display = 'block';
                    if (keySectionDivider) keySectionDivider.style.display = 'block';
                }
                // Check if profile is linked when public key changes
                checkProfileLinked();
            } else {
                document.getElementById('npub-display').value = '';
                if (npubDisplayGroup) npubDisplayGroup.style.display = 'none';
                if (keySectionDivider) keySectionDivider.style.display = 'none';
                isProfileLinked = false;
                updateLinkProfileButton();
            }
        }
        
        // Relay status tracking
        const relayStatus = new Map(); // url -> { status: 'connected'|'connecting'|'disconnected'|'error', canWrite: boolean }
        const relayWriteEnabled = new Map(); // url -> boolean
        
        // Relay management
        function getRelayUrls() {
            const saved = localStorage.getItem('relay_urls');
            if (saved) {
                return saved.split('\n').filter(url => url.trim());
            }
            return DEFAULT_RELAYS;
        }
        
        function saveRelays() {
            const urls = Array.from(relayStatus.keys());
            localStorage.setItem('relay_urls', urls.join('\n'));
            showStatus('Relays saved! Reconnecting...', 'info');
            initializeNDK();
        }
        
        function updateRelayStatus(url, status, canWrite = null) {
            const current = relayStatus.get(url) || { status: 'disconnected', canWrite: false };
            relayStatus.set(url, {
                status: status,
                canWrite: canWrite !== null ? canWrite : current.canWrite
            });
            renderRelaysList();
        }
        
        function setRelayWriteEnabled(url, enabled) {
            relayWriteEnabled.set(url, enabled);
            const current = relayStatus.get(url) || { status: 'disconnected', canWrite: false };
            relayStatus.set(url, { ...current, canWrite: enabled });
            renderRelaysList();
        }
        
        function renderRelaysList() {
            const container = document.getElementById('relays-list');
            if (!container) return;
            
            container.innerHTML = '';
            
            const urls = getRelayUrls();
            if (urls.length === 0) {
                container.innerHTML = '<p style="color: var(--muted-foreground); font-size: 0.875rem; padding: 1rem; text-align: center;">No relays configured</p>';
                return;
            }
            
            urls.forEach(url => {
                const status = relayStatus.get(url) || { status: 'disconnected', canWrite: false };
                
                const item = document.createElement('div');
                item.className = 'relay-item';
                
                // Ensure status class is always set (connected, connecting, disconnected, or error)
                const statusClass = (status && status.status) ? status.status : 'disconnected';
                const statusText = statusClass === 'connected' ? 'Connected' : 
                                  statusClass === 'connecting' ? 'Connecting...' :
                                  statusClass === 'error' ? 'Error' : 'Disconnected';
                
                item.innerHTML = `
                    <div class="relay-status-indicator ${statusClass}" title="${statusText}"></div>
                    <div class="relay-url">${url}</div>
                    <div class="relay-controls">
                        <button class="relay-delete-btn" onclick="removeRelay('${url}')">DELETE</button>
                    </div>
                `;
                
                container.appendChild(item);
            });
        }
        
        function addRelay() {
            const input = document.getElementById('new-relay-url');
            const url = input.value.trim();
            
            if (!url) {
                showStatus('Please enter a relay URL', 'error');
                return;
            }
            
            if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                showStatus('Relay URL must start with ws:// or wss://', 'error');
                return;
            }
            
            const urls = getRelayUrls();
            if (urls.includes(url)) {
                showStatus('Relay already exists', 'error');
                return;
            }
            
            // Add to status tracking
            relayStatus.set(url, { status: 'disconnected', canWrite: true });
            relayWriteEnabled.set(url, true);
            
            // Save to localStorage
            const allUrls = [...urls, url];
            localStorage.setItem('relay_urls', allUrls.join('\n'));
            
            input.value = '';
            renderRelaysList();
            showStatus('Relay added! Reconnecting...', 'info');
            initializeNDK();
        }
        
        function removeRelay(url) {
            if (!confirm(`Remove relay ${url}?`)) {
                return;
            }
            
            // Remove from status tracking
            relayStatus.delete(url);
            relayWriteEnabled.delete(url);
            
            // Remove from localStorage
            const urls = getRelayUrls().filter(u => u !== url);
            if (urls.length > 0) {
                localStorage.setItem('relay_urls', urls.join('\n'));
            } else {
                localStorage.removeItem('relay_urls');
            }
            
            renderRelaysList();
            showStatus('Relay removed! Reconnecting...', 'info');
            initializeNDK();
        }
        
        // Load cached events on initialization
        function loadCachedEvents() {
            const cachedEvents = loadEventsFromCache();
            if (cachedEvents && cachedEvents.length > 0) {
                events = cachedEvents;
                cachedFilteredEvents = null; // Invalidate filtered events cache
                filteredEventsCacheKey = null;
                rebuildSpatialIndex(); // Build spatial index for cached events
                // Update UI with cached events
                if (map && map.loaded()) {
                    updateMapMarkers();
                    updatePlusCodeGrid();
                } else if (map) {
                    // Wait for map to load, then update
                    map.once('load', () => {
                        updateMapMarkers();
                        updatePlusCodeGrid();
                    });
                }
                return true;
            }
            return false;
        }
        
        async function initializeNDK() {
            const relayUrls = getRelayUrls();
            // Initialize relays
            
            // Initialize status for all relays
            relayUrls.forEach(url => {
                if (!relayStatus.has(url)) {
                    relayStatus.set(url, { status: 'connecting', canWrite: relayWriteEnabled.get(url) !== false });
                    relayWriteEnabled.set(url, relayWriteEnabled.get(url) !== false);
                } else {
                    updateRelayStatus(url, 'connecting');
                }
            });
            renderRelaysList();
            
            try {
                if (NDK) {
                    // Use NDK if available
                    ndk = new NDK({
                        explicitRelayUrls: relayUrls
                    });
                    
                    await ndk.connect();
                    
                    // Update status for all relays (NDK manages connections internally)
                    // Note: NDK doesn't provide per-relay status, so we assume all are connected
                    let connectedCount = 0;
                    relayUrls.forEach(url => {
                        // Try to check if relay is actually connected via NDK pool
                        try {
                            const relay = ndk.pool?.relays?.get(url);
                            if (relay && relay.status === 1) {
                                updateRelayStatus(url, 'connected', relayWriteEnabled.get(url) !== false);
                                connectedCount++;
                            } else {
                                updateRelayStatus(url, 'connecting', relayWriteEnabled.get(url) !== false);
                            }
                        } catch (e) {
                            // If we can't check, assume connected (NDK manages this)
                            updateRelayStatus(url, 'connected', relayWriteEnabled.get(url) !== false);
                            connectedCount++;
                        }
                    });
                    
                    if (connectedCount > 0) {
                        showStatus(`Connected to ${connectedCount} relay(s) (NDK)`, 'success');
                    } else {
                        showStatus('Connecting to relays (NDK)...', 'info');
                    }
                    
                    // Start subscribing to events
                    subscribeToEvents();
                    subscribeToPlusCodePrefixes();
                } else {
                    // Fallback to direct Relay connections
                    showStatus('Using direct relay connections', 'info');
                    await initializeRelays(relayUrls);
                }
            } catch (error) {
                console.error('[NDK] Error initializing NDK:', error.message || error);
                // Fallback to direct relays
                showStatus('Falling back to direct relay connections', 'info');
                await initializeRelays(relayUrls);
            }
        }
        
        async function initializeRelays(relayUrls) {
            relays = [];
            
            // Initialize status for all relays
            relayUrls.forEach(url => {
                if (!relayStatus.has(url)) {
                    relayStatus.set(url, { status: 'connecting', canWrite: relayWriteEnabled.get(url) !== false });
                    relayWriteEnabled.set(url, relayWriteEnabled.get(url) !== false);
                } else {
                    updateRelayStatus(url, 'connecting');
                }
            });
            renderRelaysList();
            
            for (const url of relayUrls) {
                try {
                    updateRelayStatus(url, 'connecting');
                    const relay = await Relay.connect(url);
                    relays.push(relay);
                    // Ensure relayWriteEnabled is set before updating status
                    if (!relayWriteEnabled.has(url)) {
                        relayWriteEnabled.set(url, true);
                    }
                    // Set status to connected immediately after successful connection
                    updateRelayStatus(url, 'connected', relayWriteEnabled.get(url) !== false);
                    
                    // Subscribe to events - kind 0 (profiles), kind 5 (deletions), kind 10390 (Trustroots profiles), and kind 30397 (map notes)
                    const kinds = [0, DELETION_KIND, TRUSTROOTS_PROFILE_KIND, MAP_NOTE_KIND];
                    
                    // First, do a direct query for kind 30397 events to see how many exist
                    let directQueryCount = 0;
                    const directQuery = relay.subscribe([{ kinds: [MAP_NOTE_KIND] }], {
                        onevent: (event) => {
                            directQueryCount++;
                            // Process these events too
                            processIncomingEvent(event);
                        },
                        oneose: () => {
                            directQuery.close();
                        }
                    });
                    
                    // Also subscribe to all kinds to get other events
                    const sub = relay.subscribe([{ kinds }], {
                        onevent: (event) => {
                            // Debug: Uncomment to see all received events
                            // console.log('[Relay] Received event:', event.kind, event.id?.substring(0, 16));
                            processIncomingEvent(event);
                        },
                        oneose: () => {
                            // EOSE received
                        }
                    });
                    
                    // Query for existing kind 10390 profile events to populate username map
                    const profileQuery = relay.subscribe([{ kinds: [TRUSTROOTS_PROFILE_KIND] }], {
                        onevent: (event) => {
                            processIncomingEvent(event);
                        },
                        oneose: () => {
                            profileQuery.close();
                        }
                    });
                    
                    // Note: nostr-tools Relay doesn't expose a .status property we can check
                    // Once connected, we trust the connection is good until we get a publish error
                    
                    // Keep subscription alive
                    setInterval(() => {
                        if (relay.status === 1) { // OPEN
                            relay.subscribe([{ kinds: [0, DELETION_KIND, TRUSTROOTS_PROFILE_KIND, MAP_NOTE_KIND], limit: 1 }], {
                                onevent: () => {},
                                oneose: () => {}
                            });
                        }
                    }, 30000); // Every 30 seconds
                } catch (error) {
                    console.error(`[Relay] Error connecting to ${url}:`, error.message || error);
                    updateRelayStatus(url, 'error', false);
                }
            }
            
            // Show summary message
            const connectedCount = relays.length;
            const totalCount = relayUrls.length;
            const failedCount = totalCount - connectedCount;
            
            if (connectedCount > 0) {
                if (failedCount > 0) {
                    showStatus(`Connected to ${connectedCount} of ${totalCount} relay(s)`, 'success');
                } else {
                    showStatus(`Connected to ${connectedCount} relay(s)`, 'success');
                }
                // Subscribe to plus code prefixes
                subscribeToPlusCodePrefixes();
            } else {
                showStatus(`Failed to connect to any relays`, 'error');
            }
        }
        
        function subscribeToEvents() {
            if (ndk) {
                // Use NDK subscription - kind 0 (profiles), kind 5 (deletions), kind 10390 (Trustroots profiles), and kind 30397 (map notes)
                const kinds = [0, DELETION_KIND, TRUSTROOTS_PROFILE_KIND, MAP_NOTE_KIND];
                
                const filter = {
                    kinds: kinds
                };
                
                try {
                    const subscription = ndk.subscribe(filter, { closeOnEose: false });
                    
                    subscription.on('event', (event) => {
                        // NDK event might have rawEvent() method or be the event itself
                        const rawEvent = event.rawEvent ? event.rawEvent() : event;
                        console.log('[NDK] Received event:', rawEvent.kind, rawEvent.id?.substring(0, 16));
                        processIncomingEvent(rawEvent);
                    });
                } catch (error) {
                    console.error('Error setting up NDK subscription:', error);
                    // Fallback to direct relays
                    const relayUrls = getRelayUrls();
                    initializeRelays(relayUrls);
                }
            }
            // Direct relay subscriptions are handled in initializeRelays
        }
        
        // Subscribe to plus code prefixes for better event discovery
        function subscribeToPlusCodePrefixes() {
            if (!ndk && relays.length === 0) return;
            
            // Get current map bounds to determine which plus codes to subscribe to
            if (!map || !map.loaded()) {
                // Subscribe to a broad set initially (common areas)
                const prefixes = ['8C000000+', '8F000000+', '8G000000+', '9C000000+', '9F000000+', '9G000000+'];
                subscribeToPlusCodes(prefixes);
            } else {
                // Subscribe based on current view
                const bounds = map.getBounds();
                const regionBounds = {
                    north: bounds.getNorth(),
                    south: bounds.getSouth(),
                    east: bounds.getEast(),
                    west: bounds.getWest()
                };
                const codeLength = 4; // Use 4-character codes for subscription
                const visiblePlusCodes = allPlusCodesForRegion(regionBounds, codeLength);
                const prefixes = visiblePlusCodes.map(code => {
                    const clean = code.replace('+', '').substring(0, 4);
                    return clean.padEnd(8, '0') + '+';
                });
                // Limit to avoid too many subscriptions
                const limitedPrefixes = prefixes.slice(0, 50);
                subscribeToPlusCodes(limitedPrefixes);
            }
        }
        
        function subscribeToPlusCodes(prefixes) {
            if (prefixes.length === 0) return;
            
            // Only subscribe to kind 30397 for plus code subscriptions
            const kinds = [MAP_NOTE_KIND];
            
            // Create filters for plus code prefixes
            // Note: NDK and nostr-tools use different filter formats
            // For nostr-tools, we need to filter by 'l' tag with 'open-location-code-prefix' as the third element
            // Since we can't directly filter by the third element in nostr-tools, we'll use a broader filter
            // and filter client-side, or use the prefix values directly
            // Note: This subscription is in addition to the main subscription, not a replacement
            // The main subscription should already be getting all events
            const filters = [{
                kinds: kinds,
                '#l': prefixes
            }];
            
            if (ndk) {
                try {
                    const subscription = ndk.subscribe(filters, { closeOnEose: false });
                    subscription.on('event', (event) => {
                        const rawEvent = event.rawEvent ? event.rawEvent() : event;
                        processIncomingEvent(rawEvent);
                    });
                } catch (error) {
                    console.error('Error subscribing to plus codes:', error);
                }
            } else {
                // Use direct relay subscriptions
                // Note: This is an additional subscription for plus code filtering
                // The main subscription in initializeRelays should already be getting all events
                relays.forEach(relay => {
                    if (relay.status === 1) { // OPEN
                        try {
                            relay.subscribe(filters, {
                                onevent: (event) => {
                                    processIncomingEvent(event);
                                },
                                oneose: () => {
                                    // EOSE received
                                }
                            });
                        } catch (error) {
                            console.error('Error subscribing to relay:', error);
                        }
                    }
                });
            }
        }
        
        // Get storage ID for an event (matches nr-app logic)
        function getStorageId(event) {
            const { id, kind, pubkey } = event;
            
            // Replaceable events
            if (kind === 0 || (kind >= 10000 && kind < 20000)) {
                return `${pubkey}:${kind}`;
            }
            
            // Parameterized replaceable events (kind 30397, 30398, etc.)
            if (kind >= 30000 && kind < 40000) {
                const dTag = event.tags.find(([tagName]) => tagName === 'd');
                if (dTag && dTag.length > 1) {
                    const tagValue = dTag[1];
                    if (typeof tagValue === 'string' && tagValue.length > 0) {
                        return `${pubkey}:${kind}:${tagValue}`;
                    }
                }
                // For parameterized replaceable events without a valid "d" tag,
                // use the event ID to ensure each event is stored separately
                return id;
            }
            
            return id;
        }
        
        // localStorage caching functions
        function saveEventsToCache() {
            try {
                const cacheData = {
                    events: events,
                    timestamp: Date.now()
                };
                localStorage.setItem(EVENTS_CACHE_KEY, JSON.stringify(cacheData));
                localStorage.setItem(EVENTS_CACHE_TIMESTAMP_KEY, cacheData.timestamp.toString());
            } catch (error) {
                console.warn('Failed to save events to cache:', error);
                // Handle quota exceeded error
                if (error.name === 'QuotaExceededError') {
                    // Try to clear old cache or reduce size
                    try {
                        // Remove oldest events if cache is too large
                        const sortedEvents = [...events].sort((a, b) => a.created_at - b.created_at);
                        const reducedEvents = sortedEvents.slice(-1000); // Keep last 1000 events
                        const cacheData = {
                            events: reducedEvents,
                            timestamp: Date.now()
                        };
                        localStorage.setItem(EVENTS_CACHE_KEY, JSON.stringify(cacheData));
                        localStorage.setItem(EVENTS_CACHE_TIMESTAMP_KEY, cacheData.timestamp.toString());
                        console.log('Reduced cache size to 1000 events');
                    } catch (e) {
                        console.error('Failed to save reduced cache:', e);
                    }
                }
            }
        }
        
        function loadEventsFromCache() {
            try {
                const cacheDataStr = localStorage.getItem(EVENTS_CACHE_KEY);
                const timestampStr = localStorage.getItem(EVENTS_CACHE_TIMESTAMP_KEY);
                
                if (!cacheDataStr || !timestampStr) {
                    return null;
                }
                
                const timestamp = parseInt(timestampStr);
                const age = Date.now() - timestamp;
                
                // Check if cache is still valid (within 24 hours)
                if (age > CACHE_MAX_AGE) {
                    return null;
                }
                
                const cacheData = JSON.parse(cacheDataStr);
                if (cacheData && cacheData.events && Array.isArray(cacheData.events)) {
                    return cacheData.events;
                }
            } catch (error) {
                console.warn('Failed to load events from cache:', error);
            }
            return null;
        }
        
        // Batched localStorage write - debounced to avoid excessive writes
        function scheduleCacheWrite() {
            if (localStorageWriteTimeout) {
                clearTimeout(localStorageWriteTimeout);
            }
            localStorageWriteTimeout = setTimeout(() => {
                saveEventsToCache();
                localStorageWriteTimeout = null;
            }, 2000); // Write to cache 2 seconds after last event
        }
        
        // Expiration setting functions (matching nr-app)
        function getExpirationSetting() {
            const saved = localStorage.getItem(EXPIRATION_SETTING_KEY);
            if (saved) {
                const parsed = parseInt(saved);
                // Validate it's one of the allowed values
                const validValues = [HOUR_IN_SECONDS, DAY_IN_SECONDS, WEEK_IN_SECONDS, MONTH_IN_SECONDS, YEAR_IN_SECONDS];
                if (!isNaN(parsed) && validValues.includes(parsed)) {
                    return parsed;
                }
            }
            return WEEK_IN_SECONDS; // Default to 1 week (matching nr-app)
        }
        
        function saveExpirationSetting(value) {
            const parsed = parseInt(value);
            // Validate it's one of the allowed values
            const validValues = [HOUR_IN_SECONDS, DAY_IN_SECONDS, WEEK_IN_SECONDS, MONTH_IN_SECONDS, YEAR_IN_SECONDS];
            if (!isNaN(parsed) && validValues.includes(parsed)) {
                localStorage.setItem(EXPIRATION_SETTING_KEY, parsed.toString());
                // Sync expiration input
                document.getElementById('note-expiration-in-modal').value = parsed;
            }
        }
        
        // Get current timestamp (matching nr-app's getCurrentTimestamp)
        function getCurrentTimestamp() {
            return Math.round(Date.now() / 1000);
        }
        
        // Track all kind 30397 events for debugging
        let kind30397EventsReceived = 0;
        let kind30397EventsProcessed = 0;
        let kind30397EventsRejected = 0;
        
        // Extract Trustroots username from kind 10390 profile event
        function getTrustrootsUsernameFromProfileEvent(event) {
            if (event.kind !== TRUSTROOTS_PROFILE_KIND) {
                return undefined;
            }
            
            // Look for label tags with the Trustroots username namespace
            // Format: ["l", value, "org.trustroots:username"]
            const usernameTag = event.tags.find(tag => 
                tag.length >= 3 && 
                tag[0] === "l" && 
                tag[2] === TRUSTROOTS_USERNAME_LABEL_NAMESPACE
            );
            
            if (usernameTag && usernameTag[1]) {
                return usernameTag[1];
            }
            
            return undefined;
        }
        
        function processIncomingEvent(event) {
            // Process kind 10390 (Trustroots profile) events to extract usernames
            if (event.kind === TRUSTROOTS_PROFILE_KIND) {
                const username = getTrustrootsUsernameFromProfileEvent(event);
                if (username) {
                    pubkeyToUsername.set(event.pubkey, username);
                }
                return; // Don't process these as map notes
            }
            
            // Process kind 5 (deletion) events - store them but don't display as notes
            if (event.kind === DELETION_KIND) {
                const storageId = getStorageId(event);
                const existingIndex = events.findIndex(e => getStorageId(e) === storageId);
                
                if (existingIndex === -1) {
                    // New deletion event, add it
                    const eventData = {
                        id: event.id,
                        kind: event.kind,
                        pubkey: event.pubkey,
                        content: event.content,
                        created_at: event.created_at,
                        tags: event.tags,
                        sig: event.sig
                    };
                    events.push(eventData);
                    scheduleCacheWrite();
                    cachedFilteredEvents = null;
                    filteredEventsCacheKey = null;
                    // Rebuild spatial index to update filtering
                    rebuildSpatialIndex();
                    // Update UI to reflect deletions
                    updateMapMarkers();
                    if (map && map.loaded()) {
                        updatePlusCodeGrid();
                    }
                    
                    // If notes modal is open, check if any deleted events match the selected plus code
                    const notesModal = document.getElementById('pluscode-notes-modal');
                    if (notesModal && notesModal.classList.contains('active') && selectedPlusCode) {
                        // Find which events are being deleted by this deletion event
                        const deletedEventIds = event.tags
                            .filter(tag => tag.length >= 2 && tag[0] === 'e')
                            .map(tag => tag[1]);
                        
                        // Check if any of the deleted events match the selected plus code
                        let shouldRefresh = false;
                        for (const deletedEventId of deletedEventIds) {
                            const deletedEvent = events.find(e => e.id === deletedEventId);
                            if (deletedEvent) {
                                const deletedEventPlusCode = getPlusCodeFromEvent(deletedEvent);
                                if (deletedEventPlusCode) {
                                    const eventMatches = deletedEventPlusCode === selectedPlusCode || 
                                                        isPlusCodeInsidePlusCode(selectedPlusCode, deletedEventPlusCode);
                                    if (eventMatches) {
                                        shouldRefresh = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // If a deleted event matches, refresh the modal
                        if (shouldRefresh) {
                            setTimeout(() => {
                                showNotesForPlusCode(selectedPlusCode);
                            }, 100);
                        }
                    }
                }
                return; // Don't process deletion events as map notes
            }
            
            // Track all kind 30397 events
            if (event.kind === MAP_NOTE_KIND) {
                kind30397EventsReceived++;
            }
            
            // Only process events with valid kinds (0 for profiles, 30397 for map notes)
            // Note: We subscribe to kind 0 but don't process it here - it's for profile data
            // We only process kind 30397 (map notes) in this function
            if (event.kind !== MAP_NOTE_KIND) {
                // Allow kind 0 through but don't process it (it's handled elsewhere if needed)
                if (event.kind === 0) {
                    return; // Skip profile events in map note processing
                }
                return; // Skip all other kinds
            }
            
            // Only process events that have a plus code
            const plusCode = getPlusCodeFromEvent(event);
            if (!plusCode) {
                if (event.kind === MAP_NOTE_KIND) {
                    kind30397EventsRejected++;
                }
                return;
            }
            
            const storageId = getStorageId(event);
            
            // Check if an event with this storage ID already exists
            const existingIndex = events.findIndex(e => getStorageId(e) === storageId);
            
            if (existingIndex !== -1) {
                const existingEvent = events[existingIndex];
                
                // If it's the same event ID, skip (already have it)
                if (existingEvent.id === event.id) {
                    return;
                }
                
                // For replaceable events, keep the latest version
                const isUpdatedVersion = event.created_at > existingEvent.created_at;
                if (isUpdatedVersion) {
                    if (event.kind === MAP_NOTE_KIND) {
                        console.log('Replacing event with newer version:', event.id.substring(0, 16) + '...');
                    }
                    // Replace the existing event with the newer one
                    events[existingIndex] = {
                        id: event.id,
                        kind: event.kind,
                        pubkey: event.pubkey,
                        content: event.content,
                        created_at: event.created_at,
                        tags: event.tags,
                        sig: event.sig
                    };
                    scheduleCacheWrite(); // Schedule cache write (debounced)
                    cachedFilteredEvents = null; // Invalidate cache
                    filteredEventsCacheKey = null;
                    rebuildSpatialIndex(); // Rebuild spatial index (synchronous)
                    updateMapMarkers();
                    // Force grid update immediately - spatial index is already rebuilt synchronously
                    if (map && map.loaded()) {
                        // Call directly without setTimeout to ensure immediate update
                        updatePlusCodeGrid();
                    } else {
                        // If map not ready, schedule update for when it is
                        if (map) {
                            map.once('load', () => {
                                updatePlusCodeGrid();
                            });
                        }
                    }
                    
                    // If notes modal is open, refresh it to show updated event
                    const notesModal = document.getElementById('pluscode-notes-modal');
                    if (notesModal && notesModal.classList.contains('active') && selectedPlusCode && plusCode) {
                        const eventMatches = plusCode === selectedPlusCode || 
                                            isPlusCodeInsidePlusCode(selectedPlusCode, plusCode);
                        if (eventMatches) {
                            setTimeout(() => {
                                showNotesForPlusCode(selectedPlusCode);
                            }, 150);
                        }
                    }
                }
                // If not newer, ignore it
                return;
            }
            
            // New event, add it
            if (event.kind === MAP_NOTE_KIND) {
                kind30397EventsProcessed++;
                // Debug: Uncomment to see new map note events
                // console.log('[ProcessEvent] New MAP_NOTE_KIND event:', event.id?.substring(0, 16), 'plusCode:', plusCode);
            }
            
            const eventData = {
                id: event.id,
                kind: event.kind,
                pubkey: event.pubkey,
                content: event.content,
                created_at: event.created_at,
                tags: event.tags,
                sig: event.sig
            };
            
            events.push(eventData);
            // Debug: Uncomment to see event processing
            // console.log('[ProcessEvent] Event added to array, total events:', events.length);
            scheduleCacheWrite(); // Schedule cache write (debounced)
            cachedFilteredEvents = null; // Invalidate cache
            filteredEventsCacheKey = null;
            rebuildSpatialIndex(); // Rebuild spatial index (synchronous)
            // Debug: Uncomment to see spatial index rebuild
            // console.log('[ProcessEvent] Spatial index rebuilt, continuing to UI updates...');
            
            try {
                updateMapMarkers();
                // Debug: Uncomment to see marker updates
                // console.log('[ProcessEvent] updateMapMarkers completed');
            } catch (e) {
                console.error('[ProcessEvent] Error in updateMapMarkers:', e);
            }
            
            // Force grid update immediately - spatial index is already rebuilt synchronously
            try {
                if (map && map.loaded()) {
                    // Call directly without setTimeout to ensure immediate update
                    updatePlusCodeGrid();
                    // Debug: Uncomment to see grid updates
                    // console.log('[ProcessEvent] updatePlusCodeGrid completed');
                } else {
                    // If map not ready, schedule update for when it is
                    if (map) {
                        map.once('load', () => {
                            updatePlusCodeGrid();
                        });
                    }
                }
            } catch (e) {
                console.error('[ProcessEvent] Error in updatePlusCodeGrid:', e);
            }
            
            // Debug: Uncomment to see modal refresh checks
            // console.log('[ProcessEvent] About to check modal refresh...');
            
            // If notes modal is open, refresh it to show new events
            // Since events are showing on the map, they're in the spatial index
            // We'll refresh the modal and let showNotesForPlusCode filter correctly using the spatial index
            const notesModal = document.getElementById('pluscode-notes-modal');
            const isModalActive = notesModal && notesModal.classList.contains('active');
            
            // Try to get the plus code from the modal title if selectedPlusCode is not set
            let modalPlusCode = selectedPlusCode;
            if (isModalActive && !modalPlusCode) {
                const titleElement = document.getElementById('pluscode-notes-title');
                if (titleElement) {
                    // Extract plus code from title like "X notes for 5G000000+"
                    const titleText = titleElement.textContent;
                    const match = titleText.match(/for\s+([A-Z0-9]+\+)/);
                    if (match && match[1]) {
                        modalPlusCode = match[1];
                        console.log('[Modal Refresh] Extracted plus code from modal title:', modalPlusCode);
                    }
                }
            }
            
            // Always log the check for debugging
            console.log('[Modal Refresh Check]', {
                hasModal: !!notesModal,
                isModalActive: isModalActive,
                selectedPlusCode: selectedPlusCode,
                modalPlusCode: modalPlusCode,
                eventPlusCode: plusCode,
                eventId: event.id?.substring(0, 16),
                eventKind: event.kind
            });
            
            // If modal is open and we have a plus code (from selectedPlusCode or modal title), check if we should refresh
            if (isModalActive && modalPlusCode) {
                // Check if the new event might be relevant to the selected plus code
                let shouldRefresh = false;
                
                if (plusCode) {
                    // Check if event matches the selected plus code area
                    const exactMatch = plusCode === modalPlusCode;
                    const insideMatch = isPlusCodeInsidePlusCode(modalPlusCode, plusCode);
                    shouldRefresh = exactMatch || insideMatch;
                    
                    console.log('[Modal Refresh Check] Plus code comparison:', {
                        eventPlusCode: plusCode,
                        modalPlusCode: modalPlusCode,
                        exactMatch: exactMatch,
                        insideMatch: insideMatch,
                        shouldRefresh: shouldRefresh
                    });
                } else {
                    console.log('[Modal Refresh Check] No plus code for event, skipping refresh');
                }
                
                if (shouldRefresh) {
                    // Refresh the modal - showNotesForPlusCode will use the updated spatial index
                    // to filter and display events correctly
                    console.log('[Modal Refresh] Refreshing modal for new event');
                    // Use requestAnimationFrame to ensure DOM is ready, then refresh
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            showNotesForPlusCode(modalPlusCode);
                        }, 100);
                    });
                } else {
                    console.log('[Modal Refresh] Skipping refresh - event does not match selected plus code');
                }
            } else {
                // Log why we're not refreshing
                if (!isModalActive) {
                    console.log('[Modal Refresh] Modal not active - skipping refresh');
                } else if (!modalPlusCode) {
                    console.log('[Modal Refresh] Modal active but no plus code available - skipping refresh');
                }
            }
        }
        
        // Sync localStorage with relay contents - remove events that no longer exist on relays
        function syncLocalStorageWithRelays() {
            if (events.length === 0) {
                return; // Nothing to sync
            }
            
            console.log('Starting sync: checking which events still exist on relays...');
            const eventsOnRelays = new Set();
            let queriesCompleted = 0;
            const totalRelays = ndk ? 1 : relays.length;
            
            if (totalRelays === 0) {
                console.log('No relays available for sync');
                return;
            }
            
            // Perform the actual sync - remove events not found on relays
            const performSync = (eventsOnRelaysSet) => {
                const initialCount = events.length;
                const eventsToRemove = [];
                
                // Find events that are not on any relay
                events.forEach((event, index) => {
                    const storageId = getStorageId(event);
                    if (!eventsOnRelaysSet.has(storageId)) {
                        eventsToRemove.push(index);
                    }
                });
                
                // Remove events in reverse order to maintain indices
                eventsToRemove.reverse().forEach(index => {
                    events.splice(index, 1);
                });
                
                const removedCount = eventsToRemove.length;
                
                if (removedCount > 0) {
                    console.log(`Sync complete: Removed ${removedCount} event(s) that no longer exist on relays (${initialCount} -> ${events.length})`);
                    
                    // Update cache
                    saveEventsToCache();
                    cachedFilteredEvents = null;
                    filteredEventsCacheKey = null;
                    
                    // Rebuild spatial index
                    rebuildSpatialIndex();
                    
                    // Update UI
                    updateMapMarkers();
                    if (map && map.loaded()) {
                        updatePlusCodeGrid();
                    }
                } else {
                    console.log('Sync complete: All events still exist on relays');
                }
            };
            
            // Query all events from relays
            if (ndk) {
                // Use NDK to query all kind 30397 events
                try {
                    const filter = { kinds: [MAP_NOTE_KIND] };
                    const subscription = ndk.subscribe(filter, { closeOnEose: true });
                    
                    subscription.on('event', (event) => {
                        const rawEvent = event.rawEvent ? event.rawEvent() : event;
                        const storageId = getStorageId(rawEvent);
                        eventsOnRelays.add(storageId);
                    });
                    
                    subscription.on('eose', () => {
                        queriesCompleted++;
                        if (queriesCompleted >= totalRelays) {
                            performSync(eventsOnRelays);
                        }
                    });
                } catch (error) {
                    console.error('Error querying events via NDK:', error);
                    queriesCompleted++;
                    if (queriesCompleted >= totalRelays) {
                        performSync(eventsOnRelays);
                    }
                }
            } else {
                // Query each relay directly
                for (const relay of relays) {
                    try {
                        const query = relay.subscribe([{ kinds: [MAP_NOTE_KIND] }], {
                            onevent: (event) => {
                                const storageId = getStorageId(event);
                                eventsOnRelays.add(storageId);
                            },
                            oneose: () => {
                                query.close();
                                queriesCompleted++;
                                if (queriesCompleted >= totalRelays) {
                                    performSync(eventsOnRelays);
                                }
                            }
                        });
                        
                        // Timeout after 30 seconds per relay
                        setTimeout(() => {
                            if (query) {
                                query.close();
                            }
                            queriesCompleted++;
                            if (queriesCompleted >= totalRelays) {
                                performSync(eventsOnRelays);
                            }
                        }, 30000);
                    } catch (error) {
                        console.error(`Error querying relay ${relay.url}:`, error);
                        queriesCompleted++;
                        if (queriesCompleted >= totalRelays) {
                            performSync(eventsOnRelays);
                        }
                    }
                }
            }
        }
        
        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function formatDate(timestamp) {
            const date = new Date(timestamp * 1000);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }
        
        
        function updateMapMarkers() {
            if (!map) return;
            
            // Clear existing markers - nr-app style uses only the plus code grid,
            // not individual markers. Markers are disabled to match nr-app behavior.
            markers.forEach(marker => marker.remove());
            markers = [];
            
            // NOTE: Individual markers are disabled to match nr-app's grid-only visualization.
            // The plus code grid (updatePlusCodeGrid) handles the visual representation.
            // If you want to enable markers, uncomment the code below:
            /*
            // Get enabled layers
            const enabledLayers = getEnabledLayers();
            
            // Filter events by enabled layers and add markers
            // Only show non-expired events
            events.forEach(event => {
                // Skip expired events
                if (isEventExpired(event)) {
                    return;
                }
                
                const layer = getLayerForEvent(event);
                if (layer && enabledLayers.includes(layer)) {
                    const plusCode = getPlusCodeFromEvent(event);
                    if (plusCode) {
                        // Pass plus code directly, conversion happens in addMarkerToMap
                        addMarkerToMap(event, plusCode, layer);
                    }
                }
            });
            */
        }
        
        function getPlusCodeFromEvent(event) {
            // Find plus code in tags
            for (const tag of event.tags) {
                if (tag.length >= 3 && tag[0] === 'l' && tag[2] === 'open-location-code') {
                    return tag[1];
                }
            }
            return null;
        }
        
        function isEventExpired(event) {
            // Check if event has an expiration tag (matching nr-app logic)
            for (const tag of event.tags) {
                if (tag.length >= 2 && tag[0] === 'expiration') {
                    const expirationTimestamp = parseInt(tag[1]);
                    if (!isNaN(expirationTimestamp)) {
                        const currentTimestamp = getCurrentTimestamp();
                        return expirationTimestamp <= currentTimestamp;
                    }
                }
            }
            // If no expiration tag, event is not expired
            return false;
        }
        
        // Get the expiration timestamp from an event (NIP-40)
        function getExpirationTimestamp(event) {
            for (const tag of event.tags) {
                if (tag.length >= 2 && tag[0] === 'expiration') {
                    const expirationTimestamp = parseInt(tag[1]);
                    if (!isNaN(expirationTimestamp)) {
                        return expirationTimestamp;
                    }
                }
            }
            return null;
        }
        
        // Get remaining seconds until event expires
        function getRemainingTime(event) {
            const expirationTimestamp = getExpirationTimestamp(event);
            if (expirationTimestamp === null) {
                return null;
            }
            return expirationTimestamp - getCurrentTimestamp();
        }
        
        // Format remaining time for display (e.g., "7d", "5h", "45m", "<1m")
        function formatRemainingTime(seconds) {
            if (seconds === null) return null;
            if (seconds <= 0) return 'expired';
            
            const days = Math.floor(seconds / (24 * 60 * 60));
            const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));
            const minutes = Math.floor((seconds % (60 * 60)) / 60);
            
            if (days > 0) {
                return `${days}d`;
            } else if (hours > 0) {
                return `${hours}h`;
            } else if (minutes > 0) {
                return `${minutes}m`;
            } else {
                return '<1m';
            }
        }
        
        // Check if an event has been deleted (has a corresponding kind 5 deletion event)
        function isEventDeleted(event) {
            // Deletion events themselves should not be considered as deleted
            if (event.kind === DELETION_KIND) {
                return false;
            }
            
            // Check if there's a kind 5 event that references this event ID
            return events.some(deletionEvent => {
                if (deletionEvent.kind !== DELETION_KIND) {
                    return false;
                }
                
                // Check if any 'e' tag matches this event's ID
                return deletionEvent.tags.some(tag => {
                    return tag.length >= 2 && tag[0] === 'e' && tag[1] === event.id;
                });
            });
        }
        
        // Flush expired events from the events array (matching nr-app's flushExpiredEvents)
        function flushExpiredEvents() {
            const currentTimestamp = getCurrentTimestamp();
            const initialCount = events.length;
            const eventsToKeep = events.filter(event => {
                // Check if event has an expiration tag
                for (const tag of event.tags) {
                    if (tag.length >= 2 && tag[0] === 'expiration') {
                        const expirationTimestamp = parseInt(tag[1]);
                        if (!isNaN(expirationTimestamp)) {
                            // If expired, don't keep it
                            if (expirationTimestamp <= currentTimestamp) {
                                return false;
                            }
                        }
                    }
                }
                // If no expiration tag or not expired, keep it
                return true;
            });
            
            const removedCount = initialCount - eventsToKeep.length;
            if (removedCount > 0) {
                events = eventsToKeep;
                console.log(`Flushed ${removedCount} expired event(s) (${initialCount} -> ${events.length})`);
                
                // Update cache
                saveEventsToCache();
                cachedFilteredEvents = null;
                filteredEventsCacheKey = null;
                
                // Rebuild spatial index
                rebuildSpatialIndex();
                
                // Update UI
                updateMapMarkers();
                if (map && map.loaded()) {
                    updatePlusCodeGrid();
                }
            }
        }
        
        // Start periodic flushing of expired events (matching nr-app: every 10 minutes)
        function startPeriodicFlushingOfExpiredEvents() {
            const FLUSH_EXPIRED_EVENTS_EVERY_MILLISECONDS = 10 * 60 * 1000; // 10 minutes
            setInterval(() => {
                flushExpiredEvents();
            }, FLUSH_EXPIRED_EVENTS_EVERY_MILLISECONDS);
        }
        
        function getLayerForEvent(event) {
            for (const [key, layer] of Object.entries(MAP_LAYERS)) {
                if (layer.filter.kinds && layer.filter.kinds.includes(event.kind)) {
                    if (!layer.filter.authors || layer.filter.authors.includes(event.pubkey)) {
                        return key;
                    }
                }
            }
            return null;
        }
        
        function getEnabledLayers() {
            // Always return trustroots layer - no toggles
            return ['trustroots'];
        }
        
        
        function addMarkerToMap(event, plusCode, layerKey) {
            const layer = MAP_LAYERS[layerKey];
            if (!layer) return;
            
            // Convert plus code to coordinates for map display
            const coords = decodePlusCode(plusCode);
            if (!coords) return;
            
            const el = document.createElement('div');
            el.style.width = '14px';
            el.style.height = '14px';
            el.style.borderRadius = '50%';
            el.style.backgroundColor = layer.markerColor;
            el.style.border = '2px solid white';
            el.style.cursor = 'pointer';
            el.style.zIndex = '1000';
            el.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.3)';
            el.style.transition = 'transform 0.2s ease';
            
            // Add hover effect
            el.addEventListener('mouseenter', () => {
                el.style.transform = 'scale(1.3)';
            });
            el.addEventListener('mouseleave', () => {
                el.style.transform = 'scale(1)';
            });
            
            // Store event data on the element for click handler
            el.dataset.eventId = event.id;
            
            const marker = new maplibregl.Marker(el)
                .setLngLat([coords.longitude, coords.latitude])
                .addTo(map);
            
            // Handle marker click - stop propagation to prevent map click
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                showNotesForPlusCode(plusCode);
            });
            
            // Also handle mousedown to prevent map click
            el.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });
            
            markers.push(marker);
        }
        
        // Get map style based on current theme
        function getMapStyle() {
            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark' || 
                             (!document.documentElement.getAttribute('data-theme') && 
                              !document.documentElement.hasAttribute('data-theme'));
            
            if (isDarkMode) {
                // Dark mode: Use CARTO Dark Matter tiles (production-friendly, no API key required)
                return {
                    version: 8,
                    sources: {
                        'carto-dark': {
                            type: 'raster',
                            tiles: [
                                'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                                'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                                'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
                            ],
                            tileSize: 256,
                            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors ¬© <a href="https://carto.com/attributions">CARTO</a>'
                        }
                    },
                    layers: [{
                        id: 'carto-dark',
                        type: 'raster',
                        source: 'carto-dark'
                    }]
                };
            } else {
                // Light mode: Use CARTO Voyager tiles (production-friendly, no API key required)
                return {
                    version: 8,
                    sources: {
                        'carto-voyager': {
                            type: 'raster',
                            tiles: [
                                'https://a.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
                                'https://b.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
                                'https://c.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png'
                            ],
                            tileSize: 256,
                            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors ¬© <a href="https://carto.com/attributions">CARTO</a>'
                        }
                    },
                    layers: [{
                        id: 'carto-voyager',
                        type: 'raster',
                        source: 'carto-voyager'
                    }]
                };
            }
        }
        
        function initializeMap() {
            try {
                const mapContainer = document.getElementById('map');
                if (!mapContainer) {
                    throw new Error('Map container not found');
                }
                
                // Load saved map position from localStorage
                let savedCenter = [0, 0];
                let savedZoom = 2;
                try {
                    const savedCenterStr = localStorage.getItem('map_center');
                    const savedZoomStr = localStorage.getItem('map_zoom');
                    if (savedCenterStr) {
                        savedCenter = JSON.parse(savedCenterStr);
                    }
                    if (savedZoomStr) {
                        savedZoom = parseFloat(savedZoomStr);
                    }
                } catch (e) {
                    console.warn('Failed to load saved map position:', e);
                }
                
                map = new maplibregl.Map({
                    container: 'map',
                    style: getMapStyle(),
                    center: savedCenter,
                    zoom: savedZoom,
                    renderWorldCopies: false, // Improve performance
                    antialias: true, // Smoother rendering
                    fadeDuration: 0, // Instant transitions for smoother panning
                    dragPan: true, // Explicitly enable panning
                    boxZoom: true,
                    doubleClickZoom: true
                });
                
                // Track if we've already attempted fallback to prevent repeated attempts
                let fallbackAttempted = false;
                
                map.on('error', (e) => {
                    console.error('Map error:', e);
                    
                    // Only attempt fallback once
                    if (fallbackAttempted) {
                        return;
                    }
                    fallbackAttempted = true;
                    
                    showStatus('Map loading error. Trying fallback style...', 'error');
                    // Try fallback styles in order
                    const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark' || 
                                     (!document.documentElement.getAttribute('data-theme') && 
                                      !document.documentElement.hasAttribute('data-theme'));
                    
                    const fallbackStyles = [
                        'https://demotiles.maplibre.org/style.json',
                        isDarkMode ? {
                            version: 8,
                            sources: {
                                'carto-dark-fallback': {
                                    type: 'raster',
                                    tiles: [
                                        'https://a.basemaps.cartocdn.com/tiles/dark_all/{z}/{x}/{y}.png',
                                        'https://b.basemaps.cartocdn.com/tiles/dark_all/{z}/{x}/{y}.png',
                                        'https://c.basemaps.cartocdn.com/tiles/dark_all/{z}/{x}/{y}.png'
                                    ],
                                    tileSize: 256,
                                    attribution: '¬© OpenStreetMap contributors ¬© CARTO'
                                }
                            },
                            layers: [{
                                id: 'carto-dark-fallback',
                                type: 'raster',
                                source: 'carto-dark-fallback'
                            }]
                        } : {
                            version: 8,
                            sources: {
                                'carto-positron': {
                                    type: 'raster',
                                    tiles: ['https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', 'https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', 'https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'],
                                    tileSize: 256,
                                    attribution: '¬© OpenStreetMap contributors ¬© CARTO'
                                }
                            },
                            layers: [{
                                id: 'carto-positron',
                                type: 'raster',
                                source: 'carto-positron'
                            }]
                        }
                    ];
                    
                    let fallbackIndex = 0;
                    const tryFallback = () => {
                        if (fallbackIndex < fallbackStyles.length) {
                            try {
                                map.setStyle(fallbackStyles[fallbackIndex]);
                            } catch (fallbackError) {
                                console.error('Fallback style failed:', fallbackError);
                                fallbackIndex++;
                                tryFallback();
                            }
                        }
                    };
                    tryFallback();
                });
            } catch (error) {
                console.error('Error initializing map:', error);
                showStatus('Error initializing map: ' + error.message, 'error');
                return;
            }
            
            // Track if map was dragged to prevent opening modal after panning
            let mapWasDragged = false;
            let dragStartPos = null;
            
            map.on('dragstart', () => {
                mapWasDragged = false;
                isDragging = true;
                // Cancel any pending grid updates during drag
                if (gridUpdateAnimationFrame) {
                    cancelAnimationFrame(gridUpdateAnimationFrame);
                    gridUpdateAnimationFrame = null;
                }
                // Change cursor to grabbing during pan
                if (map.getCanvas()) {
                    map.getCanvas().style.cursor = 'grabbing';
                }
            });
            
            map.on('drag', () => {
                mapWasDragged = true;
            });
            
            map.on('dragend', () => {
                isDragging = false;
                // Reset cursor to default after panning
                if (map.getCanvas()) {
                    map.getCanvas().style.cursor = 'default';
                }
                // Reset after a short delay to allow click event to check the flag
                setTimeout(() => {
                    mapWasDragged = false;
                }, 100);
                // Trigger grid update after dragging is complete
                if (pendingGridUpdate) {
                    pendingGridUpdate = false;
                    // Use a longer delay to ensure smooth drag completion
                    setTimeout(() => {
                        if (!isDragging) {
                            updatePlusCodeGrid();
                        }
                    }, 100);
                }
            });
            
            // Also track mouse events for more reliable detection
            map.on('mousedown', (e) => {
                // Only track if not clicking on a marker or control
                const target = e.originalEvent.target;
                if (target && (target.closest && (target.closest('.maplibregl-marker') || target.closest('.maplibregl-ctrl')))) {
                    return;
                }
                dragStartPos = { x: e.point.x, y: e.point.y };
                mapWasDragged = false;
                // Change cursor to grabbing when mouse is pressed
                if (map.getCanvas()) {
                    map.getCanvas().style.cursor = 'grabbing';
                }
            });
            
            map.on('mousemove', (e) => {
                if (dragStartPos) {
                    const dx = Math.abs(e.point.x - dragStartPos.x);
                    const dy = Math.abs(e.point.y - dragStartPos.y);
                    // If mouse moved more than 5 pixels, consider it a drag
                    if (dx > 5 || dy > 5) {
                        mapWasDragged = true;
                    }
                }
            });
            
            map.on('mouseup', () => {
                dragStartPos = null;
                // Reset cursor to default when mouse is released
                if (map.getCanvas() && !isDragging) {
                    map.getCanvas().style.cursor = 'default';
                }
            });
            
            // Handle map clicks (but not on plus code polygons or markers - those are handled separately)
            map.on('click', (e) => {
                // Ignore clicks that occurred after dragging/panning
                if (mapWasDragged) {
                    return;
                }
                
                // Check if clicking on a marker (markers are HTML elements, not map features)
                const clickedElement = e.originalEvent.target;
                if (clickedElement && clickedElement.closest && clickedElement.closest('.maplibregl-marker')) {
                    // Marker click is handled by the marker's own event listener
                    return;
                }
                
                // Only handle if not clicking on a plus code polygon
                const features = map.queryRenderedFeatures(e.point, { layers: ['pluscode-grid-fill'] });
                if (features.length === 0) {
                    // Convert clicked coordinates to plus code immediately
                    const plusCode = encodePlusCode(e.lngLat.lat, e.lngLat.lng);
                    if (plusCode) {
                        showNotesForPlusCode(plusCode);
                    } else {
                        showStatus('Error encoding location to plus code', 'error');
                    }
                }
            });
            
            // Update plus code grid when map moves or zooms
            let moveTimeout;
            map.on('moveend', () => {
                // Save map position and zoom to localStorage
                const center = map.getCenter();
                const zoom = map.getZoom();
                localStorage.setItem('map_center', JSON.stringify([center.lng, center.lat]));
                localStorage.setItem('map_zoom', zoom.toString());
                
                // Don't update grid during active dragging - wait for dragend
                if (isDragging) {
                    pendingGridUpdate = true;
                    return;
                }
                
                clearTimeout(moveTimeout);
                moveTimeout = setTimeout(() => {
                    if (!isDragging) {
                        updatePlusCodeGrid();
                        // Re-subscribe to new plus codes in view
                        subscribeToPlusCodePrefixes();
                    }
                }, 500); // Increased debounce for better performance
            });
            
            map.on('zoomend', () => {
                // Save map zoom to localStorage
                const zoom = map.getZoom();
                localStorage.setItem('map_zoom', zoom.toString());
                
                clearTimeout(moveTimeout);
                moveTimeout = setTimeout(() => {
                    updatePlusCodeGrid();
                    subscribeToPlusCodePrefixes();
                }, 500); // Increased debounce for better performance
            });
            
            map.on('load', () => {
                // Ensure map is interactive and set initial cursor
                if (map.getCanvas()) {
                    map.getCanvas().style.cursor = 'default';
                    // Ensure pointer events are enabled for dragging
                    map.getCanvas().style.pointerEvents = 'auto';
                }
                
                // Initialize plus code grid source
                if (!map.getSource('pluscode-grid')) {
                    map.addSource('pluscode-grid', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: []
                        }
                    });
                    
                    map.addLayer({
                        id: 'pluscode-grid-fill',
                        type: 'fill',
                        source: 'pluscode-grid',
                        paint: {
                            'fill-color': ['get', 'fillColor'],
                            'fill-opacity': 1
                        }
                    });
                    
                    map.addLayer({
                        id: 'pluscode-grid-stroke',
                        type: 'line',
                        source: 'pluscode-grid',
                        paint: {
                            'line-color': 'rgba(80, 80, 90, 0.5)',
                            'line-width': 1
                        }
                    });
                    
                    // Make plus code polygons clickable
                    map.on('click', 'pluscode-grid-fill', (e) => {
                        // Ignore clicks that occurred after dragging/panning
                        if (mapWasDragged) {
                            return;
                        }
                        
                        if (e.features && e.features.length > 0) {
                            const plusCode = e.features[0].properties.plusCode;
                            if (plusCode) {
                                selectedPlusCode = plusCode;
                                showNotesForPlusCode(plusCode);
                            }
                        }
                    });
                    
                    // Change cursor on hover over plus codes
                    map.on('mouseenter', 'pluscode-grid-fill', () => {
                        if (map.getCanvas()) {
                            map.getCanvas().style.cursor = 'pointer';
                        }
                    });
                    
                    map.on('mouseleave', 'pluscode-grid-fill', () => {
                        // Reset to default cursor when not hovering over plus code
                        if (map.getCanvas() && !dragStartPos) {
                            map.getCanvas().style.cursor = 'default';
                        }
                    });
                }
                
                updatePlusCodeGrid();
            });
            
            // Layer toggles removed - trustroots layer is always enabled
        }
        
        function updatePlusCodeGrid() {
            if (!map || !map.loaded()) {
                // If map not ready, try again after a short delay
                setTimeout(() => {
                    if (map && map.loaded()) {
                        updatePlusCodeGrid();
                    }
                }, 100);
                return;
            }
            
            // Don't update grid during active dragging
            if (isDragging) {
                pendingGridUpdate = true;
                return;
            }
            
            // Cancel any pending animation frame
            if (gridUpdateAnimationFrame) {
                cancelAnimationFrame(gridUpdateAnimationFrame);
            }
            
            // Use requestAnimationFrame for smooth rendering, but execute immediately
            // This ensures the update happens in the next frame
            const updateGrid = () => {
                const bounds = map.getBounds();
                const latitudeDelta = bounds.getNorth() - bounds.getSouth();
                const longitudeDelta = bounds.getEast() - bounds.getWest();
                
                // Handle world-wrapping: if longitude delta > 360, use full longitude range
                const worldWrapping = longitudeDelta >= 360;
                const effectiveLongitudeDelta = worldWrapping ? 360 : longitudeDelta;
                
                const codeLength = whatLengthOfPlusCodeToShow(latitudeDelta, effectiveLongitudeDelta);
                
                // Get effective bounds for plus code generation
                const effectiveWest = worldWrapping ? -180 : bounds.getWest();
                const effectiveEast = worldWrapping ? 180 : bounds.getEast();
                
                // Get southwest and northeast plus codes
                const sw = encodePlusCode(bounds.getSouth(), effectiveWest, codeLength);
                const ne = encodePlusCode(bounds.getNorth(), effectiveEast, codeLength);
                
                if (!sw || !ne) {
                    gridUpdateAnimationFrame = null;
                    return;
                }
                
                // Get all plus codes between southwest and northeast
                const allVisiblePlusCodes = getAllPlusCodesBetweenTwoPlusCodes(sw, ne, codeLength);
                
                // OPTIMIZATION: Only render plus codes that have events or are adjacent to ones with events
                // First, collect all plus codes that have events in the viewport
                const plusCodesWithEvents = new Set();
                const features = [];
                const processedPlusCodes = new Set();
                
                // First pass: collect all plus codes with events that are in or near the viewport
                // This ensures we don't miss any plus codes with events
                eventsByPlusCode.forEach((eventSet, plusCode) => {
                    if (eventSet.size > 0) {
                        // Check if this plus code is in the viewport or close to it
                        const decoded = decodePlusCode(plusCode);
                        if (decoded) {
                            const inBounds = decoded.latitude >= bounds.getSouth() && 
                                          decoded.latitude <= bounds.getNorth() &&
                                          decoded.longitude >= bounds.getWest() && 
                                          decoded.longitude <= bounds.getEast();
                            // Include if in bounds or close (within 2x the code length resolution)
                            if (inBounds) {
                                plusCodesWithEvents.add(plusCode);
                            }
                        }
                    }
                });
                
                // Second pass: iterate through visible plus codes and ones with events
                const allPlusCodesToCheck = new Set([...allVisiblePlusCodes, ...plusCodesWithEvents]);
                
                for (const plusCode of allPlusCodesToCheck) {
                    if (processedPlusCodes.has(plusCode)) continue;
                    if (features.length >= MAX_GRID_FEATURES) break; // Limit features
                    
                    // Use fast spatial index lookup
                    const { eventsForPlusCodeExactly, eventsWithinPlusCode } = filterEventsForPlusCodeFast(plusCode);
                    const eventCountExactly = eventsForPlusCodeExactly.length;
                    const eventCountWithin = eventsWithinPlusCode.length;
                    const totalEventCount = eventCountExactly + eventCountWithin;
                    
                    // Render all visible cells (both with and without events) up to the limit
                    // This ensures complete grid coverage without gaps
                    {
                        const rectangle = plusCodeToRectangle(plusCode);
                        if (!rectangle) continue;
                        
                        // Calculate fill color based on event count
                        // Colors designed for dark map readability
                        let fillColor;
                        if (selectedPlusCode && plusCode === selectedPlusCode) {
                            fillColor = `rgba(64, 156, 255, 0.7)`; // Soft blue for selected
                        } else if (totalEventCount > 0) {
                            // Gradient from dark maroon to brighter red based on event count
                            const intensity = Math.min(1, totalEventCount / 5);
                            const r = Math.round(80 + intensity * 100); // 80-180
                            const g = Math.round(20 + intensity * 20);  // 20-40
                            const b = Math.round(30 + intensity * 20);  // 30-50
                            fillColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                        } else {
                            fillColor = `rgba(60, 60, 70, 0.35)`; // Subtle dark gray for empty
                        }
                        
                        features.push({
                            type: 'Feature',
                            geometry: {
                                type: 'Polygon',
                                coordinates: [rectangle]
                            },
                            properties: {
                                plusCode: plusCode,
                                eventCount: totalEventCount,
                                eventCountExactly: eventCountExactly,
                                eventCountWithin: eventsWithinPlusCode.length,
                                fillColor: fillColor
                            }
                        });
                        
                        processedPlusCodes.add(plusCode);
                        if (totalEventCount > 0) {
                            plusCodesWithEvents.add(plusCode);
                        }
                    }
                }
                
                const source = map.getSource('pluscode-grid');
                if (source) {
                    // Set the data
                    source.setData({
                        type: 'FeatureCollection',
                        features: features
                    });
                    
                    // Only force re-render if not dragging (the panBy hack can interfere with dragging)
                    if (!isDragging) {
                        // Force a re-render by doing a tiny pan that's imperceptible
                        // This is the most reliable way to force MapLibre to re-render
                        map.panBy([0.1, 0], { duration: 0 });
                        setTimeout(() => {
                            if (!isDragging) {
                                map.panBy([-0.1, 0], { duration: 0 });
                            }
                        }, 1);
                    }
                } else {
                    // Source not ready yet, try again after a short delay
                    setTimeout(() => {
                        if (map && map.loaded() && map.getSource('pluscode-grid')) {
                            updatePlusCodeGrid();
                        }
                    }, 100);
                    gridUpdateAnimationFrame = null;
                    return;
                }
                
                gridUpdateAnimationFrame = null;
            };
            
            // Schedule the update
            gridUpdateAnimationFrame = requestAnimationFrame(updateGrid);
        }
        
        function showNoteDetails(event) {
            const plusCode = getPlusCodeFromEvent(event);
            const layer = getLayerForEvent(event);
            const layerTitle = layer ? MAP_LAYERS[layer].title : 'Unknown';
            
            // Get username safely
            const username = pubkeyToUsername.get(event.pubkey);
            let authorDisplay = '';
            if (username) {
                try {
                    const npub = nip19.npubEncode(event.pubkey);
                    authorDisplay = `@${escapeHtml(username)} (${escapeHtml(npub)})`;
                } catch(e) {
                    authorDisplay = `@${escapeHtml(username)} (${escapeHtml(event.pubkey.substring(0, 16))}...)`;
                }
            } else {
                try { 
                    authorDisplay = escapeHtml(nip19.npubEncode(event.pubkey));
                } catch(e) { 
                    authorDisplay = escapeHtml(event.pubkey.substring(0, 16)) + '...'; 
                }
            }
            
            const details = document.getElementById('note-details');
            details.innerHTML = `
                <div class="event-header">
                    <span><strong>${escapeHtml(formatDate(event.created_at))}</strong></span>
                    <span>Kind: ${escapeHtml(String(event.kind))}</span>
                </div>
                <div class="event-header" style="margin-top: 0.5rem;">
                    <span>Layer: ${escapeHtml(layerTitle)}</span>
                    ${plusCode ? `<span style="font-family: monospace; color: var(--primary);">${escapeHtml(plusCode)}</span>` : ''}
                </div>
                <div class="event-header" style="margin-top: 0.5rem; font-size: 0.85rem;">
                    <span style="font-family: monospace;">${authorDisplay}</span>
                </div>
                <div class="event-content" style="margin: 1rem 0; padding: 1rem; background: var(--muted); border-radius: calc(var(--radius) - 2px);">
                    ${escapeHtml(event.content)}
                </div>
                <div class="event-tags" style="margin-top: 1rem;">
                    <strong>Tags:</strong><br>
                    <pre style="font-size: 0.8rem; margin-top: 0.5rem; background: var(--muted); padding: 0.5rem; border-radius: calc(var(--radius) - 2px); overflow-x: auto; border: 1px solid var(--border);">${escapeHtml(JSON.stringify(event.tags, null, 2))}</pre>
                </div>
            `;
            document.getElementById('view-note-modal').classList.add('active');
        }
        
        function closeViewNoteModal() {
            document.getElementById('view-note-modal').classList.remove('active');
        }
        
        function closePlusCodeNotesModal() {
            document.getElementById('pluscode-notes-modal').classList.remove('active');
            document.getElementById('note-content-in-modal').value = '';
            document.getElementById('note-expiration-in-modal').value = getExpirationSetting();
            // Clear selected circle when closing modal
            clearSelectedCircle('modal');
            // Clear selected plus code and update grid to remove highlight
            selectedPlusCode = null;
            updatePlusCodeGrid();
        }
        
        // Circle selection functions
        function showCirclesModal() {
            const modal = document.getElementById('circles-modal');
            const circlesList = document.getElementById('circles-list');
            
            // Clear existing circles
            circlesList.innerHTML = '';
            
            // Get Trustroots circles
            const circles = getTrustrootsCircles();
            
            // Create circle items
            circles.forEach(circle => {
                const circleItem = document.createElement('div');
                circleItem.className = 'circle-item';
                circleItem.textContent = `#${circle.slug}`;
                circleItem.title = `#${circle.slug}`;
                
                circleItem.addEventListener('click', () => {
                    selectCircle(circle.slug);
                    hideCirclesModal();
                });
                
                circlesList.appendChild(circleItem);
            });
            
            // Show modal
            modal.style.display = 'flex';
            
            // Add ESC key listener
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    hideCirclesModal();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        function hideCirclesModal() {
            const modal = document.getElementById('circles-modal');
            modal.style.display = 'none';
        }
        
        function selectCircle(circleSlug) {
            selectedCircle = circleSlug;
            updateCircleIndicator('modal');
        }
        
        function clearSelectedCircle(context) {
            selectedCircle = null;
            if (context === 'modal') {
                updateCircleIndicator('modal');
            }
        }
        
        function updateCircleIndicator(context) {
            if (context === 'modal') {
                const indicator = document.getElementById('selected-circle-indicator-modal');
                const text = document.getElementById('selected-circle-text-modal');
                if (selectedCircle) {
                    indicator.style.display = 'block';
                    text.textContent = `Circle: #${selectedCircle}`;
                } else {
                    indicator.style.display = 'none';
                }
            }
        }
        
        async function publishNoteFromModal() {
            if (!usingNip07 && !currentPrivateKeyBytes) {
                showStatus('No private key available. Please connect extension or import/generate a key.', 'error');
                return;
            }
            
            if (!currentPublicKey) {
                showStatus('No public key available', 'error');
                return;
            }
            
            if (!selectedPlusCode) {
                showStatus('Please select a location on the map', 'error');
                return;
            }
            
            let content = document.getElementById('note-content-in-modal').value.trim();
            if (!content || content.length < 3) {
                showStatus('Note content must be at least 3 characters', 'error');
                return;
            }
            
            // Add circle hashtag to content if circle is selected
            if (selectedCircle) {
                const hashtag = `#${selectedCircle}`;
                const hashtagRegex = /#\w+/g;
                const existingHashtags = content.match(hashtagRegex) || [];
                if (!existingHashtags.includes(hashtag)) {
                    content = content + ' ' + hashtag;
                }
            }
            
            const expirationSeconds = parseInt(document.getElementById('note-expiration-in-modal').value) || WEEK_IN_SECONDS;
            const expiration = getCurrentTimestamp() + expirationSeconds;
            
            // Use the selected plus code directly
            const plusCode = selectedPlusCode;
            const plusCodePrefixes = getPlusCodePrefixes(plusCode, DERIVED_EVENT_PLUS_CODE_PREFIX_MINIMUM_LENGTH);
            
            try {
                // Build tags array
                const tags = [
                    ['expiration', expiration.toString()],
                    ['L', 'open-location-code'],
                    ['l', plusCode, 'open-location-code'],
                    ['L', 'open-location-code-prefix'],
                    ...plusCodePrefixes.map(prefix => ['l', prefix, 'open-location-code-prefix'])
                ];
                
                // Add circle tags if circle is selected
                if (selectedCircle) {
                    tags.push(['L', 'trustroots-circle']);
                    tags.push(['l', selectedCircle, 'trustroots-circle']);
                }
                
                // Create event template
                const eventTemplate = {
                    kind: MAP_NOTE_KIND,
                    content: content,
                    created_at: Math.floor(Date.now() / 1000),
                    pubkey: currentPublicKey,
                    tags: tags
                };
                
                let signedEvent;
                
                // Sign event using NIP-07 extension or local key
                if (usingNip07) {
                    // Verify extension is still available
                    if (!nostrProvider) {
                        const provider = detectNostrExtension();
                        if (provider) {
                            nostrProvider = provider;
                            try {
                                if (typeof provider.getPublicKey !== 'function') {
                                    throw new Error('getPublicKey method not available');
                                }
                                const currentPubkey = await provider.getPublicKey();
                                if (!currentPubkey || typeof currentPubkey !== 'string') {
                                    throw new Error('Invalid public key returned');
                                }
                                if (currentPubkey !== currentPublicKey) {
                                    showStatus('Extension public key changed. Please reconnect.', 'error');
                                    usingNip07 = false;
                                    updateKeyDisplay();
                                    return;
                                }
                            } catch (error) {
                                console.error('Error verifying extension public key:', error);
                                showStatus('Extension no longer available. Please reconnect.', 'error');
                                usingNip07 = false;
                                nostrProvider = null;
                                localStorage.removeItem('using_nip07');
                                updateKeyDisplay();
                                return;
                            }
                        } else {
                            showStatus('Extension no longer available. Please reconnect or use local keys.', 'error');
                            usingNip07 = false;
                            localStorage.removeItem('using_nip07');
                            updateKeyDisplay();
                            return;
                        }
                    }
                    
                    try {
                        signedEvent = await nostrProvider.signEvent(eventTemplate);
                    } catch (error) {
                        console.error('Error signing event with extension:', error);
                        showStatus('Error signing event: ' + error.message, 'error');
                        return;
                    }
                } else {
                    // Sign with local private key
                    signedEvent = finalizeEvent(eventTemplate, currentPrivateKeyBytes);
                }
                
                // Publish to all configured relays (only those with Post enabled)
                // Create new connections for each publish to avoid closed connection errors
                const relayUrls = getRelayUrls().filter(url => relayWriteEnabled.get(url) !== false);
                
                if (relayUrls.length === 0) {
                    showStatus('No relays enabled for posting. Enable "Post" toggle for at least one relay.', 'error');
                    return;
                }
                
                const publishPromises = relayUrls.map(async (url) => {
                    let relay = null;
                    try {
                        relay = await Relay.connect(url);
                        await relay.publish(signedEvent);
                        // Wait a bit for the relay to process and confirm the event
                        await new Promise(resolve => setTimeout(resolve, 500));
                        return { success: true, url };
                    } catch (error) {
                        // Only log error if it's not a generic relay rejection
                        const errorMessage = error?.message || String(error);
                        if (!errorMessage.includes('relay experienced an error')) {
                            console.error(`Error publishing to ${url}:`, error);
                        }
                        return { success: false, url, error: errorMessage };
                    } finally {
                        // Always close the relay connection, even if there was an error
                        if (relay) {
                            try {
                                relay.close();
                            } catch (closeError) {
                                // Ignore errors when closing
                            }
                        }
                    }
                });
                
                const results = await Promise.allSettled(publishPromises);
                const successful = [];
                const failed = [];
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        if (result.value.success) {
                            successful.push(result.value.url);
                        } else {
                            failed.push({ url: result.value.url, error: result.value.error });
                        }
                    } else {
                        failed.push({ url: relayUrls[index], error: result.reason?.message || 'Unknown error' });
                    }
                });
                
                if (successful.length > 0) {
                    let statusMessage = `Note published to ${successful.length} relay(s)`;
                    if (failed.length > 0) {
                        const failedRelays = failed.map(f => new URL(f.url).hostname).join(', ');
                        statusMessage += ` (${failed.length} failed: ${failedRelays})`;
                    }
                    showStatus(statusMessage, 'success');
                    // Add to local events
                    processIncomingEvent(signedEvent);
                    // Clear form and refresh notes
                    document.getElementById('note-content-in-modal').value = '';
                    document.getElementById('note-expiration-in-modal').value = getExpirationSetting();
                    // Clear selected circle after posting
                    clearSelectedCircle('modal');
                    // Refresh the notes display after a short delay to ensure grid is updated
                    setTimeout(() => {
                        showNotesForPlusCode(selectedPlusCode);
                    }, 100);
                } else {
                    const errorDetails = failed.map(f => `${new URL(f.url).hostname}`).join(', ');
                    showStatus(`Failed to publish to all relays: ${errorDetails}`, 'error');
                }
            } catch (error) {
                console.error('Error publishing note:', error);
                showStatus('Error publishing note: ' + error.message, 'error');
            }
        }
        
        function showNotesForPlusCode(plusCode) {
            selectedPlusCode = plusCode;
            
            // Use fast spatial index lookup instead of filtering all events
            const { eventsForPlusCodeExactly, eventsWithinPlusCode } = filterEventsForPlusCodeFast(plusCode);
            
            console.log('[showNotesForPlusCode]', {
                plusCode: plusCode,
                exactMatches: eventsForPlusCodeExactly.length,
                withinMatches: eventsWithinPlusCode.length,
                totalEventsInArray: events.length
            });
            
            // Merge exact matches into within plus code section, avoiding duplicates
            const allEventsMap = new Map();
            eventsForPlusCodeExactly.forEach(event => {
                allEventsMap.set(event.id, event);
            });
            eventsWithinPlusCode.forEach(event => {
                // Only add if not already in exact matches (avoid duplicates)
                if (!allEventsMap.has(event.id)) {
                    allEventsMap.set(event.id, event);
                }
            });
            
            // Fallback: If spatial index returned very few results but we have many events,
            // do a direct filter from events array as a safety check
            const spatialIndexResults = allEventsMap.size;
            if (spatialIndexResults === 0 && events.length > 0) {
                console.warn('[showNotesForPlusCode] Spatial index returned 0 results, falling back to direct filter');
                // Direct filter as fallback
                events.forEach(event => {
                    if (isEventDeleted(event) || isEventExpired(event) || event.kind === DELETION_KIND) {
                        return;
                    }
                    const eventPlusCode = getPlusCodeFromEvent(event);
                    if (eventPlusCode) {
                        const eventMatches = eventPlusCode === plusCode || 
                                            isPlusCodeInsidePlusCode(plusCode, eventPlusCode);
                        if (eventMatches) {
                            allEventsMap.set(event.id, event);
                        }
                    }
                });
                console.log('[showNotesForPlusCode] Fallback filter found', allEventsMap.size, 'events');
            }
            
            // Filter out expired events (already filtered in filterEventsForPlusCodeFast, but double-check)
            const nonExpiredEvents = Array.from(allEventsMap.values()).filter(event => {
                const isExpired = isEventExpired(event);
                const isDeleted = isEventDeleted(event);
                if (isExpired || isDeleted) {
                    console.log('[showNotesForPlusCode] Filtering out event:', {
                        eventId: event.id?.substring(0, 16),
                        isExpired: isExpired,
                        isDeleted: isDeleted
                    });
                }
                return !isExpired && !isDeleted;
            });
            
            const sortedAll = [...nonExpiredEvents].sort((a, b) => a.created_at - b.created_at);
            
            console.log('[showNotesForPlusCode] Final events to display:', {
                beforeFilter: allEventsMap.size,
                afterExpiredFilter: nonExpiredEvents.length,
                finalSorted: sortedAll.length,
                eventIds: sortedAll.map(e => e.id?.substring(0, 16))
            });
            
            // Update modal title
            document.getElementById('pluscode-notes-title').textContent = 
                `${sortedAll.length} note${sortedAll.length !== 1 ? 's' : ''} for ${plusCode}`;
            
            // Build notes content
            const notesContent = document.getElementById('pluscode-notes-content');
            notesContent.innerHTML = '';
            
            // Single section for all notes
            if (sortedAll.length > 0) {
                const notesSection = document.createElement('div');
                notesSection.className = 'notes-section';
                
                let renderedCount = 0;
                sortedAll.forEach(event => {
                    try {
                        const noteItem = createNoteItem(event);
                        notesSection.appendChild(noteItem);
                        renderedCount++;
                    } catch (error) {
                        console.error('[showNotesForPlusCode] Error creating note item:', error, event);
                    }
                });
                
                console.log('[showNotesForPlusCode] Rendered', renderedCount, 'out of', sortedAll.length, 'notes');
                
                notesContent.appendChild(notesSection);
            } else {
                // Show message if no notes
                const noNotes = document.createElement('div');
                noNotes.className = 'notes-section';
                noNotes.innerHTML = '<p style="color: var(--muted-foreground); text-align: center; padding: 2rem;">No notes yet for this plus code area.</p>';
                notesContent.appendChild(noNotes);
            }
            
            // Clear form when opening modal
            document.getElementById('note-content-in-modal').value = '';
            document.getElementById('note-expiration-in-modal').value = getExpirationSetting();
            
            // Update the grid to highlight the selected plus code in blue BEFORE panning
            updatePlusCodeGrid();
            
            // Pan map to ensure selected area is visible above the modal
            if (map) {
                const rectangle = plusCodeToRectangle(plusCode);
                if (rectangle && rectangle.length >= 4) {
                    // Get bounds from rectangle: [sw, se, ne, nw, sw]
                    const sw = rectangle[0]; // [lng, lat] of southwest corner
                    const ne = rectangle[2]; // [lng, lat] of northeast corner
                    
                    // Check if we're on mobile
                    const isMobile = window.innerWidth <= 768;
                    
                    if (isMobile) {
                        // On mobile, modal covers bottom 60%, so add bottom padding
                        // to ensure area is visible in top 40% of screen
                        // Use 65% bottom padding to push area further up, and more top padding for visibility
                        const bottomPadding = window.innerHeight * 0.65; // 65vh in pixels
                        map.fitBounds([sw, ne], {
                            padding: {
                                top: 60, // More top padding to make area more visible
                                bottom: bottomPadding,
                                left: 20,
                                right: 20
                            },
                            duration: 300 // Smooth animation
                        });
                    } else {
                        // On desktop, just ensure it's visible with standard padding
                        map.fitBounds([sw, ne], {
                            padding: 50,
                            duration: 300
                        });
                    }
                }
            }
            
            // Show modal
            document.getElementById('pluscode-notes-modal').classList.add('active');
            
            // Scroll to bottom and focus on textarea after modal is shown
            setTimeout(() => {
                // Scroll notes list to bottom
                const notesList = document.getElementById('pluscode-notes-content');
                if (notesList) {
                    notesList.scrollTop = notesList.scrollHeight;
                }
                
                // Focus on the textarea and set up keyboard handler
                const textarea = document.getElementById('note-content-in-modal');
                if (textarea) {
                    textarea.focus();
                    // Handle Enter key: submit on Enter, new line on Shift+Enter
                    // Only set up listener once
                    if (!textarea.dataset.enterHandlerSetup) {
                        textarea.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                publishNoteFromModal();
                            }
                            // Shift+Enter allows default behavior (new line)
                        });
                        textarea.dataset.enterHandlerSetup = 'true';
                    }
                }
            }, 150);
        }
        
        function createNoteItem(event) {
            const noteItem = document.createElement('div');
            noteItem.className = 'note-item';
            noteItem.style.cursor = 'pointer';
            
            const metaRow = document.createElement('div');
            metaRow.className = 'note-meta-row';
            
            const meta = document.createElement('span');
            meta.className = 'note-meta';
            meta.textContent = formatDate(event.created_at);
            
            // Get plus code from event
            const plusCode = getPlusCodeFromEvent(event);
            
            const author = document.createElement('span');
            author.className = 'note-author';
            // Show Trustroots username if available, otherwise show npub
            const username = pubkeyToUsername.get(event.pubkey);
            if (username) {
                author.textContent = `@${username}`;
                try {
                    const npub = nip19.npubEncode(event.pubkey);
                    author.title = `@${username} (${npub})`; // Show username and npub on hover
                } catch (error) {
                    author.title = `@${username} (${event.pubkey.substring(0, 16)}...)`;
                }
            } else {
                try {
                    const npub = nip19.npubEncode(event.pubkey);
                    author.textContent = npub.substring(0, 12) + '...';
                    author.title = npub; // Show full npub on hover
                } catch (error) {
                    author.textContent = event.pubkey.substring(0, 12) + '...';
                }
            }
            
            // Combine meta, author, expiry, and plus code on same line with pluscode on the right
            metaRow.appendChild(meta);
            metaRow.appendChild(document.createTextNode(' '));
            metaRow.appendChild(author);
            
            // Add expiration indicator if event has expiration
            const remainingSeconds = getRemainingTime(event);
            if (remainingSeconds !== null) {
                const expirySpan = document.createElement('span');
                expirySpan.className = 'note-expiry';
                const formattedTime = formatRemainingTime(remainingSeconds);
                expirySpan.textContent = `‚è±Ô∏è ${formattedTime}`;
                
                // Style based on urgency
                if (remainingSeconds <= 0) {
                    expirySpan.style.color = 'var(--destructive)';
                } else if (remainingSeconds < 24 * 60 * 60) {
                    // Less than 24 hours - warning color (orange/amber)
                    expirySpan.style.color = '#f59e0b';
                } else {
                    expirySpan.style.color = 'var(--muted-foreground)';
                }
                
                // Get expiration timestamp for tooltip
                const expirationTimestamp = getExpirationTimestamp(event);
                if (expirationTimestamp) {
                    const expirationDate = new Date(expirationTimestamp * 1000);
                    expirySpan.title = `Expires: ${expirationDate.toLocaleString()}`;
                }
                
                metaRow.appendChild(document.createTextNode(' '));
                metaRow.appendChild(expirySpan);
            }
            
            // Check if this is the user's own event (for delete button)
            const isCurrentUser = currentPublicKey && 
                event.pubkey.toLowerCase() === currentPublicKey.toLowerCase();
            
            // Create a wrapper for delete button and plus code (right side of meta row)
            const rightGroup = document.createElement('span');
            rightGroup.style.marginLeft = 'auto';
            rightGroup.style.display = 'flex';
            rightGroup.style.alignItems = 'center';
            rightGroup.style.gap = '0.25rem';
            
            // Add delete button if this is the user's own event
            if (isCurrentUser) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'note-delete-btn';
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'Delete this note';
                deleteBtn.setAttribute('data-note-id', event.id);
                
                // Prevent event from bubbling to noteItem click handler
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteEvent(event.id, deleteBtn);
                });
                
                rightGroup.appendChild(deleteBtn);
            }
            
            if (plusCode) {
                const plusCodeSpan = document.createElement('span');
                plusCodeSpan.className = 'note-meta';
                plusCodeSpan.style.fontFamily = 'monospace';
                plusCodeSpan.style.color = 'var(--primary)';
                plusCodeSpan.textContent = plusCode;
                rightGroup.appendChild(plusCodeSpan);
            }
            
            metaRow.appendChild(rightGroup);
            noteItem.appendChild(metaRow);
            
            const content = document.createElement('div');
            content.className = 'note-content';
            content.textContent = event.content;
            noteItem.appendChild(content);
            
            // Make clickable to show details
            noteItem.addEventListener('click', () => {
                showNoteDetails(event);
                closePlusCodeNotesModal();
            });
            
            return noteItem;
        }
        
        async function deleteEvent(eventId, deleteButton) {
            // Check if user has private key
            if (!usingNip07 && !currentPrivateKeyBytes) {
                showStatus('No private key available. Please connect extension or import/generate a key.', 'error');
                return;
            }
            
            if (!currentPublicKey) {
                showStatus('No public key available', 'error');
                return;
            }
            
            // Find the event to verify it exists and belongs to user
            const eventToDelete = events.find(e => e.id === eventId);
            if (!eventToDelete) {
                showStatus('Event not found', 'error');
                return;
            }
            
            // Verify it's the user's event
            if (eventToDelete.pubkey.toLowerCase() !== currentPublicKey.toLowerCase()) {
                showStatus('You can only delete your own events', 'error');
                return;
            }
            
            // Show confirmation dialog
            if (!confirm('Are you sure you want to delete this note?\n\nNote: Due to the decentralized nature of Nostr, we cannot guarantee that the note will be removed from all relays. Some relays may have cached copies.')) {
                return;
            }
            
            // Update button state
            if (deleteButton) {
                deleteButton.disabled = true;
                deleteButton.classList.add('deleting');
                deleteButton.textContent = '‚è≥ DELETING...';
                deleteButton.title = 'Deleting note...';
            }
            
            try {
                // Create kind 5 deletion event
                const deletionEvent = {
                    kind: DELETION_KIND,
                    content: 'Deleted by user',
                    tags: [['e', eventId]],
                    created_at: Math.floor(Date.now() / 1000),
                    pubkey: currentPublicKey
                };
                
                let signedEvent;
                
                // Sign event using NIP-07 extension or local key
                if (usingNip07) {
                    // Verify extension is still available
                    if (!nostrProvider) {
                        const provider = detectNostrExtension();
                        if (provider) {
                            nostrProvider = provider;
                            try {
                                if (typeof provider.getPublicKey !== 'function') {
                                    throw new Error('getPublicKey method not available');
                                }
                                const currentPubkey = await provider.getPublicKey();
                                if (!currentPubkey || typeof currentPubkey !== 'string') {
                                    throw new Error('Invalid public key returned');
                                }
                                if (currentPubkey !== currentPublicKey) {
                                    showStatus('Extension public key changed. Please reconnect.', 'error');
                                    usingNip07 = false;
                                    updateKeyDisplay();
                                    if (deleteButton) {
                                        deleteButton.disabled = false;
                                        deleteButton.classList.remove('deleting');
                                        deleteButton.textContent = 'üóëÔ∏è DELETE';
                                        deleteButton.title = 'Delete this note';
                                    }
                                    return;
                                }
                            } catch (error) {
                                console.error('Error verifying extension public key:', error);
                                showStatus('Extension no longer available. Please reconnect.', 'error');
                                usingNip07 = false;
                                nostrProvider = null;
                                localStorage.removeItem('using_nip07');
                                updateKeyDisplay();
                                if (deleteButton) {
                                    deleteButton.disabled = false;
                                    deleteButton.classList.remove('deleting');
                                    deleteButton.textContent = 'üóëÔ∏è DELETE';
                                    deleteButton.title = 'Delete this note';
                                }
                                return;
                            }
                        } else {
                            showStatus('Extension no longer available. Please reconnect or use local keys.', 'error');
                            usingNip07 = false;
                            localStorage.removeItem('using_nip07');
                            updateKeyDisplay();
                            if (deleteButton) {
                                deleteButton.disabled = false;
                                deleteButton.classList.remove('deleting');
                                deleteButton.textContent = 'üóëÔ∏è DELETE';
                                deleteButton.title = 'Delete this note';
                            }
                            return;
                        }
                    }
                    
                    try {
                        signedEvent = await nostrProvider.signEvent(deletionEvent);
                    } catch (error) {
                        console.error('Error signing deletion event with extension:', error);
                        showStatus('Error signing deletion event: ' + error.message, 'error');
                        if (deleteButton) {
                            deleteButton.disabled = false;
                            deleteButton.classList.remove('deleting');
                            deleteButton.textContent = 'üóëÔ∏è DELETE';
                            deleteButton.title = 'Delete this note';
                        }
                        return;
                    }
                } else {
                    // Sign with local private key
                    signedEvent = finalizeEvent(deletionEvent, currentPrivateKeyBytes);
                }
                
                // Publish to all configured relays
                const relayUrls = getRelayUrls();
                
                if (relayUrls.length === 0) {
                    showStatus('No relays configured', 'error');
                    return;
                }
                
                if (deleteButton && relayUrls.length > 0) {
                    deleteButton.textContent = `‚è≥ SENDING TO ${relayUrls.length} RELAYS...`;
                }
                
                const publishPromises = relayUrls.map(async (url, index) => {
                    let relay = null;
                    try {
                        if (deleteButton && relayUrls.length > 1) {
                            deleteButton.textContent = `‚è≥ SENDING TO RELAY ${index + 1}/${relayUrls.length}...`;
                        }
                        
                        relay = await Relay.connect(url);
                        await relay.publish(signedEvent);
                        // Wait a bit for the relay to process
                        await new Promise(resolve => setTimeout(resolve, 500));
                        return { success: true, url };
                    } catch (error) {
                        // For deletion events, we'll consider it successful if we sent it
                        // even if we don't get a proper OK response
                        const errorMessage = error?.message || String(error);
                        if (!errorMessage.includes('relay experienced an error')) {
                            console.error(`Error publishing deletion to ${url}:`, error);
                        }
                        return { success: true, url }; // Consider deletion sent even on error
                    } finally {
                        if (relay) {
                            try {
                                relay.close();
                            } catch (closeError) {
                                // Ignore errors when closing
                            }
                        }
                    }
                });
                
                const results = await Promise.allSettled(publishPromises);
                const successCount = results.filter(r => r.status === 'fulfilled').length;
                
                // Update button to show completion
                if (deleteButton) {
                    deleteButton.textContent = '‚úÖ DELETED!';
                    deleteButton.classList.remove('deleting');
                    deleteButton.classList.add('deleted');
                }
                
                // Remove event from local events array
                const eventIndex = events.findIndex(e => e.id === eventId);
                if (eventIndex !== -1) {
                    events.splice(eventIndex, 1);
                }
                
                // Also add the deletion event to events array so it can be used for filtering
                const deletionEventData = {
                    id: signedEvent.id,
                    kind: signedEvent.kind,
                    pubkey: signedEvent.pubkey,
                    content: signedEvent.content,
                    created_at: signedEvent.created_at,
                    tags: signedEvent.tags,
                    sig: signedEvent.sig
                };
                events.push(deletionEventData);
                
                // Update cache
                saveEventsToCache();
                cachedFilteredEvents = null;
                filteredEventsCacheKey = null;
                
                // Rebuild spatial index
                rebuildSpatialIndex();
                
                // Update UI
                updateMapMarkers();
                if (map && map.loaded()) {
                    updatePlusCodeGrid();
                }
                
                // Refresh notes list if modal is open
                if (selectedPlusCode) {
                    setTimeout(() => {
                        showNotesForPlusCode(selectedPlusCode);
                    }, 100);
                }
                
                // Show success message
                showStatus(`Note deleted on ${successCount} relays`, 'success');
                
                // Brief delay to show success state, then remove from UI
                setTimeout(() => {
                    if (selectedPlusCode) {
                        showNotesForPlusCode(selectedPlusCode);
                    }
                }, 500);
                
            } catch (error) {
                console.error('Error deleting note:', error);
                
                // Reset button state on error
                if (deleteButton) {
                    deleteButton.disabled = false;
                    deleteButton.classList.remove('deleting');
                    deleteButton.textContent = 'üóëÔ∏è DELETE';
                    deleteButton.title = 'Delete this note';
                }
                
                showStatus('Failed to delete note: ' + error.message, 'error');
            }
        }
        
        function closeOnboardingModal() {
            document.getElementById('onboarding-modal').classList.remove('active');
        }
        
        function closeActiveModal() {
            // Close any active modal
            const modals = document.querySelectorAll('.modal.active');
            modals.forEach(modal => {
                if (modal.id === 'onboarding-modal') {
                    // Don't allow closing onboarding modal with ESC (user must generate/import key)
                    return;
                } else if (modal.id === 'view-note-modal') {
                    closeViewNoteModal();
                } else if (modal.id === 'pluscode-notes-modal') {
                    closePlusCodeNotesModal();
                } else if (modal.id === 'settings-modal') {
                    closeSettingsModal();
                } else {
                    // Fallback: just remove active class
                    modal.classList.remove('active');
                }
            });
        }
        
        function showStatus(message, type) {
            // Get or create status container
            let statusContainer = document.getElementById('status-container');
            if (!statusContainer) {
                statusContainer = document.createElement('div');
                statusContainer.id = 'status-container';
                statusContainer.className = 'status-container';
                document.body.appendChild(statusContainer);
            }
            
            // Create status element
            const status = document.createElement('div');
            status.className = `status ${type}`;
            status.textContent = message;
            
            // Append to status container (will appear at top)
            statusContainer.appendChild(status);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (status.parentNode) {
                    status.parentNode.removeChild(status);
                }
            }, 5000);
        }
        
        // Check if profile is linked (has kind 10390 event)
        async function checkProfileLinked() {
            if (!currentPublicKey) {
                isProfileLinked = false;
                usernameFromNostr = false;
                
                // Enable username field if no public key
                const usernameInput = document.getElementById('trustroots-username');
                const usernameIndicator = document.getElementById('username-nostr-indicator');
                if (usernameInput) {
                    usernameInput.disabled = false;
                }
                if (usernameIndicator) {
                    usernameIndicator.style.display = 'none';
                }
                
                updateLinkProfileButton();
                return;
            }
            
            try {
                const relayUrls = getRelayUrls();
                let foundLinked = false;
                let linkedUsername = null;
                
                // Check each relay for kind 10390 events
                const checkPromises = relayUrls.map(async (url) => {
                    try {
                        const relay = await Relay.connect(url);
                        const sub = relay.subscribe([
                            {
                                kinds: [TRUSTROOTS_PROFILE_KIND],
                                authors: [currentPublicKey],
                                limit: 1
                            }
                        ], {
                            onevent: (event) => {
                                // Found a kind 10390 event - profile is linked
                                foundLinked = true;
                                
                                // Extract username from event tags
                                // Look for tag with "l" and namespace "org.trustroots:username"
                                const TRUSTROOTS_USERNAME_LABEL_NAMESPACE = "org.trustroots:username";
                                for (const tag of event.tags) {
                                    if (tag[0] === 'l' && tag[2] === TRUSTROOTS_USERNAME_LABEL_NAMESPACE && tag[1]) {
                                        linkedUsername = tag[1];
                                        break;
                                    }
                                }
                            },
                            oneose: () => {
                                relay.close();
                            }
                        });
                        
                        // Wait a bit for events, then close
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        sub.close();
                        relay.close();
                    } catch (error) {
                        console.error(`Error checking profile link on ${url}:`, error);
                    }
                });
                
                await Promise.allSettled(checkPromises);
                
                // Track if we cleared a username due to validation failure
                let usernameWasCleared = false;
                
                // If we found a linked username, validate it against NIP-05
                if (linkedUsername && currentPublicKey) {
                    try {
                        const response = await fetch(`https://www.trustroots.org/.well-known/nostr.json?name=${linkedUsername}`);
                        const data = await response.json();
                        
                        // Check if the username is valid and matches this pubkey
                        if (data.names && data.names[linkedUsername]) {
                            const nip5Pubkey = data.names[linkedUsername];
                            const currentPubkeyHex = currentPublicKey.toLowerCase();
                            const nip5PubkeyHex = nip5Pubkey.toLowerCase();
                            
                            // If the pubkeys don't match, clear the username
                            if (currentPubkeyHex !== nip5PubkeyHex) {
                                console.warn(`Username ${linkedUsername} from Nostr does not match NIP-05 verification. Clearing.`);
                                usernameWasCleared = true;
                                linkedUsername = null;
                                foundLinked = false;
                            }
                        } else {
                            // No valid NIP-05 found for this username, clear it
                            console.warn(`Username ${linkedUsername} from Nostr has no valid NIP-05. Clearing.`);
                            usernameWasCleared = true;
                            linkedUsername = null;
                            foundLinked = false;
                        }
                    } catch (error) {
                        // If validation fails, clear the username to be safe
                        console.warn(`Error validating username ${linkedUsername} from Nostr:`, error);
                        usernameWasCleared = true;
                        linkedUsername = null;
                        foundLinked = false;
                    }
                }
                
                isProfileLinked = foundLinked;
                
                // Update username field if we found a linked username
                const usernameInput = document.getElementById('trustroots-username');
                const usernameIndicator = document.getElementById('username-nostr-indicator');
                
                if (linkedUsername) {
                    usernameFromNostr = true;
                    if (usernameInput) {
                        usernameInput.value = linkedUsername;
                        usernameInput.disabled = true;
                    }
                    if (usernameIndicator) {
                        usernameIndicator.style.display = 'block';
                    }
                } else {
                    usernameFromNostr = false;
                    if (usernameInput) {
                        usernameInput.value = '';
                        usernameInput.disabled = false;
                        // Focus the field if it was cleared due to validation failure
                        if (usernameWasCleared) {
                            // Use setTimeout to ensure UI is ready before focusing
                            setTimeout(() => usernameInput.focus(), 100);
                        }
                    }
                    if (usernameIndicator) {
                        usernameIndicator.style.display = 'none';
                    }
                }
                
                updateLinkProfileButton();
            } catch (error) {
                console.error('Error checking profile link:', error);
                isProfileLinked = false;
                usernameFromNostr = false;
                
                // Enable username field if not from Nostr
                const usernameInput = document.getElementById('trustroots-username');
                const usernameIndicator = document.getElementById('username-nostr-indicator');
                if (usernameInput) {
                    usernameInput.disabled = false;
                }
                if (usernameIndicator) {
                    usernameIndicator.style.display = 'none';
                }
                
                updateLinkProfileButton();
            }
        }
        
        // Update link profile button visibility
        function updateLinkProfileButton() {
            const linkProfileBtn = document.getElementById('link-profile-btn');
            if (linkProfileBtn) {
                if (isProfileLinked) {
                    linkProfileBtn.style.display = 'none';
                } else {
                    linkProfileBtn.style.display = 'block';
                }
            }
        }
        
        // Settings Modal Functions
        function openSettingsModal() {
            document.getElementById('settings-modal').classList.add('active');
            // Check if profile is linked when opening settings
            if (currentPublicKey) {
                checkProfileLinked();
            }
        }
        
        function closeSettingsModal() {
            document.getElementById('settings-modal').classList.remove('active');
        }
        
        // Make functions globally accessible for onclick handlers
        window.openSettingsModal = openSettingsModal;
        window.closeSettingsModal = closeSettingsModal;
        window.saveExpirationSetting = saveExpirationSetting;
        window.addRelay = addRelay;
        window.removeRelay = removeRelay;
        window.setRelayWriteEnabled = setRelayWriteEnabled;
        
        // Onboarding
        function checkOnboarding() {
            const hasKey = localStorage.getItem('nostr_private_key');
            const wasUsingNip07 = localStorage.getItem('using_nip07') === 'true';
            
            // If user was using NIP-07, try to reconnect even if extension isn't immediately detected
            // Extensions may need time to inject content scripts in new tabs
            if (wasUsingNip07) {
                const tryReconnect = (attempt = 0, maxAttempts = 5) => {
                    const provider = detectNostrExtension();
                    
                    if (provider) {
                        // Extension detected, try to authenticate
                        setTimeout(() => {
                            authenticateWithExtension().then(success => {
                                if (!success) {
                                    // If extension connection fails, clear NIP-07 state and show onboarding
                                    usingNip07 = false;
                                    nostrProvider = null;
                                    localStorage.removeItem('using_nip07');
                                    if (!hasKey) {
                                        document.getElementById('onboarding-modal').classList.add('active');
                                        updateKeyDisplay();
                                    } else {
                                        loadKeys();
                                    }
                                }
                            }).catch(() => {
                                // Extension connection failed
                                usingNip07 = false;
                                nostrProvider = null;
                                localStorage.removeItem('using_nip07');
                                if (!hasKey) {
                                    document.getElementById('onboarding-modal').classList.add('active');
                                    updateKeyDisplay();
                                } else {
                                    loadKeys();
                                }
                            });
                        }, 200); // Small delay to ensure extension is ready
                    } else if (attempt < maxAttempts) {
                        // Extension not detected yet, retry after a delay
                        setTimeout(() => tryReconnect(attempt + 1, maxAttempts), 300);
                    } else {
                        // Extension not found after retries, clear NIP-07 state
                        usingNip07 = false;
                        nostrProvider = null;
                        localStorage.removeItem('using_nip07');
                        if (!hasKey) {
                            document.getElementById('onboarding-modal').classList.add('active');
                            updateKeyDisplay();
                        } else {
                            loadKeys();
                        }
                    }
                };
                
                // Start reconnection attempt
                tryReconnect();
            } else if (!hasKey) {
                document.getElementById('onboarding-modal').classList.add('active');
                // Ensure display is updated even when there's no key
                updateKeyDisplay();
            } else {
                loadKeys();
            }
        }
        
        async function onboardingConnectExtension() {
            const success = await authenticateWithExtension();
            if (success) {
                document.getElementById('onboarding-modal').classList.remove('active');
                showStatus('Connected via extension! Your private key is secure in the extension.', 'success');
            } else {
                // authenticateWithExtension already shows specific error messages,
                // so we don't need to show a generic one here
                // The onboarding modal will remain open so user can try other options
            }
        }
        
        function onboardingGenerate() {
            generateKeyPair();
            document.getElementById('onboarding-modal').classList.remove('active');
        }
        
        function onboardingImport() {
            const nsec = document.getElementById('onboarding-nsec').value.trim();
            if (nsec) {
                const privateKeyHex = decodeNsec(nsec);
                if (privateKeyHex) {
                    savePrivateKey(privateKeyHex);
                    loadKeys();
                    document.getElementById('onboarding-modal').classList.remove('active');
                } else {
                    showStatus('Invalid nsec', 'error');
                }
            } else {
                showStatus('Please enter an nsec', 'error');
            }
        }
        
        // Trustroots profile linking
        async function linkTrustrootsProfile() {
            const username = document.getElementById('trustroots-username').value.trim();
            if (!username) {
                showStatus('Please enter a username', 'error');
                return;
            }
            
            // Check if user has a key loaded
            if (!currentPublicKey) {
                showStatus('Please generate or import a key first', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://www.trustroots.org/.well-known/nostr.json?name=${username}`);
                const data = await response.json();
                
                // Check for nip5 validation - only proceed if valid
                if (data.names && data.names[username]) {
                    const nip5Pubkey = data.names[username];
                    
                    // Normalize both pubkeys to lowercase hex for comparison
                    const currentPubkeyHex = currentPublicKey.toLowerCase();
                    const nip5PubkeyHex = nip5Pubkey.toLowerCase();
                    
                    // Verify the pubkey matches - only store/publish if valid
                    if (currentPubkeyHex === nip5PubkeyHex) {
                        // Create kind 10390 profile event with username
                        const TRUSTROOTS_USERNAME_LABEL_NAMESPACE = "org.trustroots:username";
                        const eventTemplate = {
                            kind: TRUSTROOTS_PROFILE_KIND,
                            tags: [
                                ["L", TRUSTROOTS_USERNAME_LABEL_NAMESPACE],
                                ["l", username, TRUSTROOTS_USERNAME_LABEL_NAMESPACE],
                            ],
                            content: "",
                            created_at: Math.floor(Date.now() / 1000),
                        };
                        
                        let signedEvent;
                        
                        // Sign the event
                        if (usingNip07 && nostrProvider) {
                            try {
                                signedEvent = await nostrProvider.signEvent(eventTemplate);
                            } catch (error) {
                                showStatus('Extension signing failed: ' + error.message, 'error');
                                return;
                            }
                        } else if (currentPrivateKeyBytes) {
                            signedEvent = finalizeEvent(eventTemplate, currentPrivateKeyBytes);
                        } else {
                            showStatus('No signing method available. Please connect extension or import/generate a key.', 'error');
                            return;
                        }
                        
                        // Publish to all relays (only those with Post enabled)
                        const relayUrls = getRelayUrls().filter(url => relayWriteEnabled.get(url) !== false);
                        
                        if (relayUrls.length === 0) {
                            showStatus('No relays enabled for posting. Enable "Post" toggle for at least one relay.', 'error');
                            return;
                        }
                        
                        const publishPromises = relayUrls.map(async (url) => {
                            let relay = null;
                            try {
                                relay = await Relay.connect(url);
                                await relay.publish(signedEvent);
                                // Wait a bit for the relay to process and confirm the event
                                await new Promise(resolve => setTimeout(resolve, 500));
                                return { success: true, url };
                            } catch (error) {
                                // Only log error if it's not a generic relay rejection
                                const errorMessage = error?.message || String(error);
                                if (!errorMessage.includes('relay experienced an error')) {
                                    console.error(`Error publishing to ${url}:`, error);
                                }
                                return { success: false, url, error: errorMessage };
                            } finally {
                                // Always close the relay connection, even if there was an error
                                if (relay) {
                                    try {
                                        relay.close();
                                    } catch (closeError) {
                                        // Ignore errors when closing
                                    }
                                }
                            }
                        });
                        
                        const results = await Promise.allSettled(publishPromises);
                        const successful = [];
                        const failed = [];
                        
                        results.forEach((result, index) => {
                            if (result.status === 'fulfilled') {
                                if (result.value.success) {
                                    successful.push(result.value.url);
                                } else {
                                    failed.push({ url: result.value.url, error: result.value.error });
                                }
                            } else {
                                failed.push({ url: relayUrls[index], error: result.reason?.message || 'Unknown error' });
                            }
                        });
                        
                        if (successful.length > 0) {
                            let statusMessage = `Profile linked! Username ${username} published to ${successful.length} relay(s)`;
                            if (failed.length > 0) {
                                const failedRelays = failed.map(f => new URL(f.url).hostname).join(', ');
                                statusMessage += ` (${failed.length} failed: ${failedRelays})`;
                            }
                            showStatus(statusMessage, 'success');
                            // Mark profile as linked and update UI
                            isProfileLinked = true;
                            usernameFromNostr = true;
                            updateLinkProfileButton();
                            
                            // Update username field and disable it since it's from Nostr
                            const usernameInput = document.getElementById('trustroots-username');
                            const usernameIndicator = document.getElementById('username-nostr-indicator');
                            if (usernameInput) {
                                usernameInput.value = username;
                                usernameInput.disabled = true;
                            }
                            if (usernameIndicator) {
                                usernameIndicator.style.display = 'block';
                            }
                        } else {
                            const errorDetails = failed.map(f => `${new URL(f.url).hostname}`).join(', ');
                            showStatus(`Profile validated but failed to publish to relays: ${errorDetails}`, 'error');
                        }
                    } else {
                        showStatus(`Username ${username} is linked to a different npub. This profile does not belong to you.`, 'error');
                        
                        // Clear the username field since it doesn't belong to this profile
                        const usernameInput = document.getElementById('trustroots-username');
                        const usernameIndicator = document.getElementById('username-nostr-indicator');
                        if (usernameInput) {
                            usernameInput.value = '';
                            usernameInput.disabled = false;
                            // Focus the field so user can immediately enter a new username
                            usernameInput.focus();
                        }
                        if (usernameIndicator) {
                            usernameIndicator.style.display = 'none';
                        }
                        
                        // Reset profile link state
                        isProfileLinked = false;
                        usernameFromNostr = false;
                        updateLinkProfileButton();
                    }
                } else {
                    // No valid nip5 found - don't store username
                    showStatus('Username not found or has no valid nip5', 'error');
                }
            } catch (error) {
                showStatus('Error linking profile: ' + error.message, 'error');
            }
        }
        
        // Initialize relay list in settings
        function initializeRelayList() {
            const urls = getRelayUrls();
            urls.forEach(url => {
                if (!relayStatus.has(url)) {
                    relayStatus.set(url, { status: 'disconnected', canWrite: true });
                    relayWriteEnabled.set(url, true);
                }
            });
            renderRelaysList();
        }
        
        // Initialize relay list on page load
        initializeRelayList();
        
        // Plus code grid state
        let plusCodeGridSource = null;
        let plusCodeGridLayer = null;
        
        // ESC key handler for closing modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.keyCode === 27) {
                closeActiveModal();
            }
        });
        
        // Initialize on load
        window.addEventListener('load', async () => {
            // Wait for maplibregl to be available
            if (typeof maplibregl === 'undefined') {
                console.error('MapLibre GL not loaded');
                showStatus('Map library failed to load', 'error');
                return;
            }
            
            // Check for NIP-07 extension availability
            checkNip07OnLoad();
            
            checkOnboarding();
            
            // Initialize expiration input with saved value
            const savedExpiration = getExpirationSetting();
            const expirationSelectModal = document.getElementById('note-expiration-in-modal');
            if (expirationSelectModal) expirationSelectModal.value = savedExpiration;
            
            // Initialize relay list
            initializeRelayList();
            
            // Settings icon button click handler
            const settingsBtn = document.getElementById('settings-icon-btn');
            if (settingsBtn) {
                settingsBtn.addEventListener('click', () => {
                    openSettingsModal();
                });
            }
            
            // Close settings modal when clicking outside
            const settingsModal = document.getElementById('settings-modal');
            if (settingsModal) {
                settingsModal.addEventListener('click', (e) => {
                    if (e.target.id === 'settings-modal') {
                        closeSettingsModal();
                    }
                });
            }
            
            // Close view-note modal when clicking outside
            const viewNoteModal = document.getElementById('view-note-modal');
            if (viewNoteModal) {
                viewNoteModal.addEventListener('click', (e) => {
                    if (e.target.id === 'view-note-modal') {
                        closeViewNoteModal();
                    }
                });
            }
            
            // Close pluscode-notes modal when clicking outside
            const pluscodeNotesModal = document.getElementById('pluscode-notes-modal');
            if (pluscodeNotesModal) {
                pluscodeNotesModal.addEventListener('click', (e) => {
                    if (e.target.id === 'pluscode-notes-modal') {
                        closePlusCodeNotesModal();
                    }
                });
            }
            
            // Close circles modal when clicking outside
            const circlesModal = document.getElementById('circles-modal');
            if (circlesModal) {
                circlesModal.addEventListener('click', (e) => {
                    if (e.target.id === 'circles-modal') {
                        hideCirclesModal();
                    }
                });
            }
            
            // Add Enter key handler for note textarea
            const noteContentInModal = document.getElementById('note-content-in-modal');
            if (noteContentInModal) {
                noteContentInModal.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        publishNoteFromModal();
                    }
                });
            }
            
            // Small delay to ensure DOM is ready, then initialize map
            setTimeout(() => {
                initializeMap();
            }, 100);
            
            // Function to load data and connect to relays
            function loadDataWhenReady() {
                // Check if map is ready
                if (map && map.loaded() && map.getSource('pluscode-grid')) {
                    // Map is ready, load cached events
                    loadCachedEvents();
                    
                    // Force a grid update after loading cached events
                    setTimeout(() => {
                        updatePlusCodeGrid();
                    }, 100);
                    
                    // Then connect to relays
                    setTimeout(async () => {
                        await initializeNDK();
                        
                        // Start periodic flushing of expired events (matching nr-app)
                        startPeriodicFlushingOfExpiredEvents();
                        
                        // After everything is loaded and displayed, wait a bit then sync localStorage with relays
                        // This removes events that have been deleted/expired from relays
                        setTimeout(() => {
                            syncLocalStorageWithRelays();
                        }, 60000); // Wait 60 seconds after initialization
                    }, 500);
                } else {
                    // Map not ready yet, try again
                    setTimeout(loadDataWhenReady, 100);
                }
            }
            
            // Start checking if map is ready after giving it time to initialize
            setTimeout(loadDataWhenReady, 200);
        });
        
        // Make functions available globally
        window.generateKeyPair = generateKeyPair;
        window.importNsec = importNsec;
        window.exportNsec = exportNsec;
        window.deleteNsec = deleteNsec;
        window.saveRelays = saveRelays;
        window.linkTrustrootsProfile = linkTrustrootsProfile;
        window.publishNoteFromModal = publishNoteFromModal;
        window.closeViewNoteModal = closeViewNoteModal;
        window.closePlusCodeNotesModal = closePlusCodeNotesModal;
        window.closeSettingsModal = closeSettingsModal;
        window.onboardingGenerate = onboardingGenerate;
        window.onboardingImport = onboardingImport;
        window.onboardingConnectExtension = onboardingConnectExtension;
        window.authenticateWithExtension = authenticateWithExtension;
        window.toggleNip07 = toggleNip07;
        window.copyPublicKey = copyPublicKey;
        window.showCirclesModal = showCirclesModal;
        window.hideCirclesModal = hideCirclesModal;
        window.clearSelectedCircle = clearSelectedCircle;
        
        // Expiration-related functions (NIP-40)
        window.isEventExpired = isEventExpired;
        window.getExpirationTimestamp = getExpirationTimestamp;
        window.getRemainingTime = getRemainingTime;
        window.formatRemainingTime = formatRemainingTime;
        window.flushExpiredEvents = flushExpiredEvents;
        window.createNoteItem = createNoteItem;
    </script>
</body>
</html>
